{"version":3,"file":"index.js","sources":["../../../node_modules/@typhonjs-plugin/manager/node_modules/@typhonjs-plugin/eventbus/src/utils.js","../../../node_modules/@typhonjs-plugin/manager/node_modules/@typhonjs-plugin/eventbus/src/Eventbus.js","../../../node_modules/@typhonjs-plugin/manager/node_modules/@typhonjs-plugin/eventbus/src/EventbusProxy.js","../../../node_modules/@typhonjs-plugin/manager/node_modules/@typhonjs-plugin/eventbus/src/EventbusSecure.js","../../../node_modules/@typhonjs-plugin/manager/node_modules/@typhonjs-plugin/eventbus/src/index.js","../../../node_modules/@typhonjs-plugin/manager/node_modules/@typhonjs-utils/loader-module/src/browser/ModuleLoader.js","../../../node_modules/@typhonjs-plugin/manager/src/PluginEntry.js","../../../node_modules/@typhonjs-plugin/manager/node_modules/@typhonjs-utils/object/src/functions.js","../../../node_modules/@typhonjs-plugin/manager/src/support/invoke/PluginInvokeEvent.js","../../../node_modules/@typhonjs-plugin/manager/src/support/invoke/invokeAsyncEvent.js","../../../node_modules/@typhonjs-plugin/manager/src/utils/escapeTarget.js","../../../node_modules/@typhonjs-plugin/manager/src/utils/isValidConfig.js","../../../node_modules/@typhonjs-plugin/manager/src/utils/resolveModule.js","../../../node_modules/@typhonjs-plugin/manager/src/PluginManager.js","../../../node_modules/@typhonjs-plugin/manager/src/support/invoke/PluginInvokeSupport.js","../../../node_modules/@typhonjs-plugin/manager/src/support/invoke/invokeSyncEvent.js"],"sourcesContent":["/**\r\n * Regular expression used to split event strings.\r\n *\r\n * @type {RegExp}\r\n */\r\nexport const eventSplitter = /\\s+/;\r\n\r\n/**\r\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\r\n * callback` and jQuery-style event maps `{event: callback}`).\r\n *\r\n * @template T\r\n *\r\n * @param {Function}       iteratee - Event operation to invoke.\r\n *\r\n * @param {T}              events - Events object\r\n *\r\n * @param {string|object}  name - A single event name, compound event names, or a hash of event names.\r\n *\r\n * @param {Function}       callback - Event callback function\r\n *\r\n * @param {object}         opts - Optional parameters\r\n *\r\n * @returns {T} Events object or processed data.\r\n */\r\nexport function eventsAPI(iteratee, events, name, callback, opts)\r\n{\r\n   let i = 0, names;\r\n   if (name && typeof name === 'object')\r\n   {\r\n      // Handle event maps.\r\n      if (callback !== void 0 && 'context' in opts && opts.context === void 0) { opts.context = callback; }\r\n      for (names = objectKeys(name); i < names.length; i++)\r\n      {\r\n         events = eventsAPI(iteratee, events, names[i], name[names[i]], opts);\r\n      }\r\n   }\r\n   else if (name && eventSplitter.test(name))\r\n   {\r\n      // Handle space-separated event names by delegating them individually.\r\n      for (names = name.split(eventSplitter); i < names.length; i++)\r\n      {\r\n         events = iteratee(events, names[i], callback, opts);\r\n      }\r\n   }\r\n   else\r\n   {\r\n      // Finally, standard events.\r\n      events = iteratee(events, name, callback, opts);\r\n   }\r\n   return events;\r\n}\r\n\r\n/**\r\n * Returns a string to output for error messages including any eventbus name.\r\n *\r\n * @param {Eventbus|EventbusProxy|EventbusSecure} eventbus - The eventbus to format.\r\n *\r\n * @returns {string} A string representing the eventbus.\r\n */\r\nexport function getErrorName(eventbus)\r\n{\r\n   const name = eventbus.name;\r\n   return name !== '' ? `[${name}] ` : '';\r\n}\r\n\r\n/**\r\n * The reducing API that returns the options for an event. Any guarded event sets guard and the higher type is set.\r\n *\r\n * @param {object}   output - The output object.\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - Event callback\r\n *\r\n * @param {object}   opts - Optional parameters\r\n *\r\n * @returns {object} The output object.\r\n */\r\nexport function getOptions(output, name, callback, opts)\r\n{\r\n   const events = opts.events;\r\n\r\n   if (events)\r\n   {\r\n      const handlers = events[name];\r\n\r\n      if (Array.isArray(handlers))\r\n      {\r\n         for (const handler of handlers)\r\n         {\r\n            if (handler.options.guard)\r\n            {\r\n               output.guard = true;\r\n            }\r\n\r\n            if (handler.options.type > output.type)\r\n            {\r\n               output.type = handler.options.type;\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   return output;\r\n}\r\n\r\n/**\r\n * Provides  protected Object.keys functionality.\r\n *\r\n * @param {object}   object - Object to retrieve keys.\r\n *\r\n * @returns {string[]} Keys of object if any.\r\n */\r\nexport const objectKeys = (object) =>\r\n{\r\n   return object === null || typeof object !== 'object' ? [] : Object.keys(object);\r\n};\r\n\r\n/**\r\n * Reduces the event callbacks into a map of `{event: beforeWrapper}`. `after` unbinds the `beforeWrapper` after\r\n * it has been called the number of times specified by options.count.\r\n *\r\n * @param {Events}   map - Events object\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - Event callback\r\n *\r\n * @param {object}   opts - Function to invoke after event has been triggered once; `off()`\r\n *\r\n * @returns {Events} The Events object.\r\n */\r\nexport function beforeMap(map, name, callback, opts)\r\n{\r\n   const after = opts.after;\r\n   const count = opts.count + 1;\r\n\r\n   if (callback)\r\n   {\r\n      const beforeWrapper = map[name] = s_BEFORE(count, function()\r\n      {\r\n         return callback.apply(this, arguments);\r\n      }, () => { after(name, beforeWrapper); });\r\n\r\n      beforeWrapper._callback = callback;\r\n   }\r\n   return map;\r\n}\r\n\r\n// Module Private ----------------------------------------------------------------------------------------------------\r\n\r\n/**\r\n * Creates a function that invokes `before`, with the `this` binding and arguments of the created function, while\r\n * it's called less than `count` times. Subsequent calls to the created function return the result of the last `before`\r\n * invocation.\r\n *\r\n * `after` is invoked after the count is reduced.\r\n *\r\n * @param {number}   count - The number of calls at which `before` is no longer invoked and then `after` is invoked.\r\n *\r\n * @param {Function} before - The function to restrict.\r\n *\r\n * @param {Function} after - The function to invoke after count number of calls.\r\n *\r\n * @returns {Function} Returns the new restricted function.\r\n */\r\nconst s_BEFORE = function(count, before, after)\r\n{\r\n   let result;\r\n\r\n   return function(...args)\r\n   {\r\n      if (--count > 0) { result = before.apply(this, args); }\r\n\r\n      if (count <= 1)\r\n      {\r\n         if (after) { after.apply(this, args); }\r\n         after = void 0;\r\n         before = void 0;\r\n      }\r\n\r\n      return result;\r\n   };\r\n};\r\n","import * as Utils from './utils.js';\r\n\r\n/**\r\n * `@typhonjs-plugin/eventbus` / Provides the ability to bind and trigger custom named events.\r\n *\r\n * This module is an evolution of Backbone Events. (http://backbonejs.org/#Events). Eventbus extends the\r\n * functionality provided in Backbone Events with additional triggering methods to receive asynchronous and\r\n * synchronous results.\r\n *\r\n * ---------------\r\n */\r\nexport default class Eventbus\r\n{\r\n   /**\r\n    * Stores the name of this eventbus.\r\n    *\r\n    * @type {string}\r\n    * @private\r\n    */\r\n   #name = '';\r\n\r\n   /**\r\n    * Stores the events map for associated events and callback / context data.\r\n    *\r\n    * @type {Events|{}}\r\n    * @private\r\n    */\r\n   #events;\r\n\r\n   /**\r\n    * Provides a constructor which optionally takes the eventbus name.\r\n    *\r\n    * @param {string}   name - Optional eventbus name.\r\n    */\r\n   constructor(name = '')\r\n   {\r\n      if (typeof name !== 'string') { throw new TypeError(`'name' is not a string`); }\r\n\r\n      this.#name = name;\r\n\r\n      /**\r\n       * Stores the Listening instances for this context.\r\n       *\r\n       * @type {object.<string, Listening>}\r\n       * @private\r\n       */\r\n      this._listeners = void 0;\r\n\r\n      /**\r\n       * A unique ID set when listened to.\r\n       *\r\n       * @type {string}\r\n       * @private\r\n       */\r\n      this._listenId = void 0;\r\n\r\n      /**\r\n       * Stores the Listening instances for other contexts.\r\n       *\r\n       * @type {object.<string, Listening>}\r\n       * @private\r\n       */\r\n      this._listeningTo = void 0;\r\n   }\r\n\r\n   /**\r\n    * Just like `on`, but causes the bound callback to fire several times up to the count specified before being\r\n    * removed. When multiple events are passed in using the space separated syntax, the event\r\n    * will fire count times for every event you passed in, not once for a combination of all events.\r\n    *\r\n    * @param {number}            count - Number of times the function will fire before being removed.\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @param {object}            [context] - Event context\r\n    *\r\n    * @param {OnOptions}         [options] - Event registration options.\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   before(count, name, callback, context = void 0, options = {})\r\n   {\r\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\r\n\r\n      const data = {};\r\n      if (this.isGuarded(name, data))\r\n      {\r\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}` +\r\n          `- before() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\r\n         return this;\r\n      }\r\n\r\n      // Map the event into a `{event: beforeWrapper}` object.\r\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count, after: this.off.bind(this) });\r\n\r\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\r\n\r\n      return this.on(events, callback, context, options);\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for all stored events yielding an array with event name, callback function, and event context.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *entries(regex = void 0)\r\n   {\r\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\r\n\r\n      if (!this.#events) { return; }\r\n\r\n      if (regex)\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            if (regex.test(name))\r\n            {\r\n               for (const event of this.#events[name])\r\n               {\r\n                  yield [name, event.callback, event.context, JSON.parse(JSON.stringify(event.options))];\r\n               }\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            for (const event of this.#events[name])\r\n            {\r\n               yield [name, event.callback, event.context, JSON.parse(JSON.stringify(event.options))];\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns the current event count.\r\n    *\r\n    * @returns {number} Returns the current event count.\r\n    */\r\n   get eventCount()\r\n   {\r\n      if (!this.#events) { return 0; }\r\n\r\n      return Object.keys(this.#events).length;\r\n   }\r\n\r\n   /**\r\n    * Returns the current callback count.\r\n    *\r\n    * @returns {number} The current callback count.\r\n    */\r\n   get callbackCount()\r\n   {\r\n      if (!this.#events) { return 0; }\r\n\r\n      let count = 0;\r\n\r\n      for (const name in this.#events) { count += this.#events[name].length; }\r\n\r\n      return count;\r\n   }\r\n\r\n   /**\r\n    * Returns the options of an event name.\r\n    *\r\n    * @param {string}   name - Event name(s) to verify.\r\n    *\r\n    * @returns {DataOutOptions} The event options.\r\n    */\r\n   getOptions(name)\r\n   {\r\n      const result = Utils.eventsAPI(Utils.getOptions, { guard: false, type: 0 }, name, void 0,\r\n       { events: this.#events });\r\n\r\n      let type = void 0;\r\n\r\n      switch (result.type)\r\n      {\r\n         case 1:\r\n            type = 'sync';\r\n            break;\r\n         case 2:\r\n            type = 'async';\r\n            break;\r\n      }\r\n\r\n      return { guard: result.guard, type };\r\n   }\r\n\r\n   /**\r\n    * Returns the trigger type of an event name.\r\n    * Note: if trigger type is not set then undefined is returned for type otherwise 'sync' or 'async' is returned.\r\n    *\r\n    * @param {string}   name - Event name(s) to verify.\r\n    *\r\n    * @returns {string|undefined} The trigger type.\r\n    */\r\n   getType(name)\r\n   {\r\n      const result = Utils.eventsAPI(s_GET_TYPE, { type: 0 }, name, void 0, { events: this.#events });\r\n\r\n      switch (result.type)\r\n      {\r\n         case 1:\r\n            return 'sync';\r\n         case 2:\r\n            return 'async';\r\n         default:\r\n            return void 0;\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns whether an event name is guarded.\r\n    *\r\n    * @param {string|object}  name - Event name(s) or event map to verify.\r\n    *\r\n    * @param {object}         [data] - Stores the output of which names are guarded.\r\n    *\r\n    * @returns {boolean} Whether the given event name is guarded.\r\n    */\r\n   isGuarded(name, data = {})\r\n   {\r\n      data.names = [];\r\n      data.guarded = false;\r\n\r\n      const result = Utils.eventsAPI(s_IS_GUARDED, data, name, void 0, { events: this.#events });\r\n\r\n      return result.guarded;\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for the event names / keys of registered event listeners.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *keys(regex = void 0)\r\n   {\r\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\r\n\r\n      if (!this.#events) { return; }\r\n\r\n      if (regex)\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            if (regex.test(name))\r\n            {\r\n               yield name;\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            yield name;\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for the event names / keys of registered event listeners along with event options.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *keysWithOptions(regex = void 0)\r\n   {\r\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\r\n\r\n      if (!this.#events) { return; }\r\n\r\n      if (regex)\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            if (regex.test(name))\r\n            {\r\n               yield [name, this.getOptions(name)];\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            yield [name, this.getOptions(name)];\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns the current eventbus name.\r\n    *\r\n    * @returns {string} The current eventbus name.\r\n    */\r\n   get name()\r\n   {\r\n      return this.#name;\r\n   }\r\n\r\n   /**\r\n    * Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of\r\n    * other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can\r\n    * be removed all at once later on. The callback will always be called with object as context.\r\n    *\r\n    * @example\r\n    * view.listenTo(model, 'change', view.render);\r\n    *\r\n    * @param {object}            obj - Event context\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   listenTo(obj, name, callback)\r\n   {\r\n      if (!obj) { return this; }\r\n\r\n      const data = {};\r\n      if (s_TRY_CATCH_IS_GUARDED(obj, name, data))\r\n      {\r\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}` +\r\n          `- listenTo() failed as event name(s) are guarded for target object: ${JSON.stringify(data.names)}`);\r\n         return this;\r\n      }\r\n\r\n      const id = obj._listenId || (obj._listenId = s_UNIQUE_ID('l'));\r\n      const listeningTo = this._listeningTo || (this._listeningTo = {});\r\n      let listening = _listening = listeningTo[id];\r\n\r\n      // This object is not listening to any other events on `obj` yet.\r\n      // Setup the necessary references to track the listening callbacks.\r\n      if (!listening)\r\n      {\r\n         this._listenId || (this._listenId = s_UNIQUE_ID('l'));\r\n         listening = _listening = listeningTo[id] = new Listening(this, obj);\r\n      }\r\n\r\n      // Bind callbacks on obj.\r\n      const error = s_TRY_CATCH_ON(obj, name, callback, this);\r\n      _listening = void 0;\r\n\r\n      if (error) { throw error; }\r\n\r\n      // If the target obj is not an Eventbus, track events manually.\r\n      if (listening.interop) { listening.on(name, callback); }\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Just like `listenTo`, but causes the bound callback to fire count times before being removed.\r\n    *\r\n    * @param {number}            count - Number of times the function will fire before being removed.\r\n    *\r\n    * @param {object}            obj - Target event context.\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   listenToBefore(count, obj, name, callback)\r\n   {\r\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\r\n\r\n      // Map the event into a `{event: beforeWrapper}` object.\r\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\r\n         count,\r\n         after: this.stopListening.bind(this, obj)\r\n      });\r\n\r\n      return this.listenTo(obj, events);\r\n   }\r\n\r\n   /**\r\n    * Just like `listenTo`, but causes the bound callback to fire only once before being removed.\r\n    *\r\n    * @param {object}            obj - Target event context\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   listenToOnce(obj, name, callback)\r\n   {\r\n      // Map the event into a `{event: beforeWrapper}` object.\r\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\r\n         count: 1,\r\n         after: this.stopListening.bind(this, obj)\r\n      });\r\n\r\n      return this.listenTo(obj, events);\r\n   }\r\n\r\n   /**\r\n    * Remove a previously-bound callback function from an object. If no context is specified, all of the versions of\r\n    * the callback with different contexts will be removed. If no callback is specified, all callbacks for the event\r\n    * will be removed. If no event is specified, callbacks for all events will be removed.\r\n    *\r\n    * Note that calling model.off(), for example, will indeed remove all events on the model â€” including events that\r\n    * Backbone uses for internal bookkeeping.\r\n    *\r\n    * @example\r\n    * // Removes just the `onChange` callback.\r\n    * object.off(\"change\", onChange);\r\n    *\r\n    * // Removes all \"change\" callbacks.\r\n    * object.off(\"change\");\r\n    *\r\n    * // Removes the `onChange` callback for all events.\r\n    * object.off(null, onChange);\r\n    *\r\n    * // Removes all callbacks for `context` for all events.\r\n    * object.off(null, null, context);\r\n    *\r\n    * // Removes all callbacks on `object`.\r\n    * object.off();\r\n    *\r\n    * @param {string|object}  [name] - Event name(s) or event map.\r\n    *\r\n    * @param {Function}       [callback] - Event callback function\r\n    *\r\n    * @param {object}         [context] - Event context\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   off(name, callback = void 0, context = void 0)\r\n   {\r\n      if (!this.#events) { return this; }\r\n\r\n      this.#events = Utils.eventsAPI(s_OFF_API, this.#events, name, callback, { context, listeners: this._listeners });\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\r\n    * large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or\r\n    * \"change:selection\".\r\n    *\r\n    * To supply a context value for this when the callback is invoked, pass the optional last argument:\r\n    * model.on('change', this.render, this) or model.on({change: this.render}, this).\r\n    *\r\n    * @example\r\n    * The event string may also be a space-delimited list of several events...\r\n    * book.on(\"change:title change:author\", ...);\r\n    *\r\n    * @example\r\n    * Callbacks bound to the special \"all\" event will be triggered when any event occurs, and are passed the name of\r\n    * the event as the first argument. For example, to proxy all events from one object to another:\r\n    * proxy.on(\"all\", function(eventName) {\r\n    *    object.trigger(eventName);\r\n    * });\r\n    *\r\n    * @example\r\n    * All Backbone event methods also support an event map syntax, as an alternative to positional arguments:\r\n    * book.on({\r\n    *    \"change:author\": authorPane.update,\r\n    *    \"change:title change:subtitle\": titleView.update,\r\n    *    \"destroy\": bookView.remove\r\n    * });\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @param {object}            [context] - Event context\r\n    *\r\n    * @param {OnOptions}         [options] - Event registration options.\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   on(name, callback, context = void 0, options = {})\r\n   {\r\n      if (options == null || options.constructor !== Object)   // eslint-disable-line eqeqeq\r\n      {\r\n         throw new TypeError(`'options' must be an object literal.`);\r\n      }\r\n\r\n      const data = {};\r\n      if (this.isGuarded(name, data))\r\n      {\r\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}` +\r\n          `- on() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\r\n         return this;\r\n      }\r\n\r\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback, {\r\n         context,\r\n         ctx: this,\r\n         options,\r\n         listening: _listening\r\n      });\r\n\r\n      if (_listening)\r\n      {\r\n         const listeners = this._listeners || (this._listeners = {});\r\n         listeners[_listening.id] = _listening;\r\n\r\n         // Allow the listening to use a counter, instead of tracking callbacks for library interop.\r\n         _listening.interop = false;\r\n      }\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\r\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\r\n    * will fire once for every event you passed in, not once for a combination of all events\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @param {object}            [context] - Event context.\r\n    *\r\n    * @param {OnOptions}         [options] - Event registration options.\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   once(name, callback, context = void 0, options = {})\r\n   {\r\n      const data = {};\r\n      if (this.isGuarded(name, data))\r\n      {\r\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}` +\r\n          `- once() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\r\n         return this;\r\n      }\r\n\r\n      // Map the event into a `{event: beforeWrapper}` object.\r\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count: 1, after: this.off.bind(this) });\r\n\r\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\r\n\r\n      return this.on(events, callback, context, options);\r\n   }\r\n\r\n   /**\r\n    * Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove\r\n    * all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to\r\n    * on a specific object, or a specific event, or just a specific callback.\r\n    *\r\n    * @example\r\n    * view.stopListening();\r\n    *\r\n    * view.stopListening(model);\r\n    *\r\n    * @param {object}   obj - Event context\r\n    *\r\n    * @param {string}   [name] - Event name(s)\r\n    *\r\n    * @param {Function} [callback] - Event callback function\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   stopListening(obj, name = void 0, callback = void 0)\r\n   {\r\n      const listeningTo = this._listeningTo;\r\n      if (!listeningTo) { return this; }\r\n\r\n      const ids = obj ? [obj._listenId] : Utils.objectKeys(listeningTo);\r\n\r\n      for (let i = 0; i < ids.length; i++)\r\n      {\r\n         const listening = listeningTo[ids[i]];\r\n\r\n         // If listening doesn't exist, this object is not currently listening to obj. Break out early.\r\n         if (!listening) { break; }\r\n\r\n         listening.obj.off(name, callback, this);\r\n\r\n         if (listening.interop) { listening.off(name, callback); }\r\n      }\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\r\n    * passed along to the event callbacks.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   trigger(name, ...args)\r\n   {\r\n      if (!this.#events) { return this; }\r\n\r\n      s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_EVENTS, this.#events, name, void 0, args);\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\r\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\r\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {Promise<void|*|*[]>} A Promise with any results.\r\n    */\r\n   async triggerAsync(name, ...args)\r\n   {\r\n      if (!this.#events) { return void 0; }\r\n\r\n      const result = s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_ASYNC_EVENTS, this.#events, name, void 0, args);\r\n\r\n      // No event callbacks were triggered.\r\n      if (result === void 0) { return void 0; }\r\n\r\n      // A single Promise has been returned; just return it.\r\n      if (!Array.isArray(result)) { return result; }\r\n\r\n      // Multiple events & callbacks have been triggered so reduce the returned array of Promises and filter all\r\n      // values from each Promise result removing any undefined values.\r\n      return Promise.all(result).then((results) =>\r\n      {\r\n         let allResults = [];\r\n\r\n         for (const pResult of results)\r\n         {\r\n            if (Array.isArray(pResult))\r\n            {\r\n               allResults = allResults.concat(pResult);\r\n            }\r\n            else if (pResult !== void 0)\r\n            {\r\n               allResults.push(pResult);\r\n            }\r\n         }\r\n\r\n         return allResults.length > 1 ? allResults : allResults.length === 1 ? allResults[0] : void 0;\r\n      });\r\n   }\r\n\r\n   /**\r\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {Eventbus} This Eventbus instance.\r\n    */\r\n   triggerDefer(name, ...args)\r\n   {\r\n      setTimeout(() => { this.trigger(name, ...args); }, 0);\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\r\n    * value or in an array and passes it back to the callee in a synchronous manner.\r\n    *\r\n    * @param {string}   name - Event name(s).\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {void|*|*[]} The results of the event invocation.\r\n    */\r\n   triggerSync(name, ...args)\r\n   {\r\n      if (!this.#events) { return void 0; }\r\n\r\n      return s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_SYNC_EVENTS, this.#events, name, void 0, args);\r\n   }\r\n}\r\n\r\n// Private / internal methods ---------------------------------------------------------------------------------------\r\n\r\n/**\r\n * Global listening object\r\n *\r\n * @type {Listening}\r\n */\r\nlet _listening;\r\n\r\n/**\r\n * A listening class that tracks and cleans up memory bindings when all callbacks have been offed.\r\n */\r\nclass Listening\r\n{\r\n   /**\r\n    * @type {Events|{}}\r\n    */\r\n   #events;\r\n\r\n   /**\r\n    * @type {string}\r\n    */\r\n   #id;\r\n\r\n   /**\r\n    * @type {object}\r\n    */\r\n   #listener;\r\n\r\n   /**\r\n    * @type {object}\r\n    */\r\n   #obj;\r\n\r\n   /**\r\n    * @type {boolean}\r\n    */\r\n   #interop;\r\n\r\n   /**\r\n    * Current listening count.\r\n    *\r\n    * @type {number}\r\n    */\r\n   #count = 0;\r\n\r\n   constructor(listener, obj)\r\n   {\r\n      this.#id = listener._listenId;\r\n      this.#listener = listener;\r\n      this.#obj = obj;\r\n      this.#interop = true;\r\n   }\r\n\r\n   // Cleans up memory bindings between the listener and the listenee.\r\n   cleanup()\r\n   {\r\n      delete this.#listener._listeningTo[this.#obj._listenId];\r\n      if (!this.#interop) { delete this.#obj._listeners[this.#id]; }\r\n   }\r\n\r\n   get id() { return this.#id; }\r\n\r\n   get interop() { return this.#interop; }\r\n\r\n   get obj() { return this.#obj; }\r\n\r\n   incrementCount() { this.#count++; }\r\n\r\n   /**\r\n    * @see {@link Eventbus#on}\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @param {object}            [context] - Event context\r\n    *\r\n    * @returns {Listening} This Listening instance.\r\n    */\r\n   on(name, callback, context = void 0)\r\n   {\r\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback,\r\n      {\r\n         context,\r\n         ctx: this,\r\n         options: {},\r\n         listening: this\r\n      });\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Offs a callback (or several). Uses an optimized counter if the listenee uses Eventbus. Otherwise, falls back to\r\n    * manual tracking to support events library interop.\r\n    *\r\n    * @param {string|object}     [name] - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   [callback] - Event callback function or context for event map.\r\n    */\r\n   off(name, callback)\r\n   {\r\n      let cleanup;\r\n\r\n      if (this.#interop)\r\n      {\r\n         this.#events = Utils.eventsAPI(s_OFF_API, this.#events, name, callback, {\r\n            context: void 0,\r\n            listeners: void 0\r\n         });\r\n         cleanup = !this.#events;\r\n      }\r\n      else\r\n      {\r\n         this.#count--;\r\n         cleanup = this.#count === 0;\r\n      }\r\n\r\n      if (cleanup) { this.cleanup(); }\r\n   }\r\n\r\n   /**\r\n    * Sets interop.\r\n    *\r\n    * @param {boolean} value Value to set.\r\n    */\r\n   set interop(value)\r\n   {\r\n      /* c8 ignore next 1 */\r\n      if (typeof value !== 'boolean') { throw new TypeError(`'value' is not a boolean`); }\r\n      this.#interop = value;\r\n   }\r\n}\r\n\r\n/**\r\n * The reducing API that returns the trigger type for an event. The higher type is set.\r\n *\r\n * @param {object}   output - The output object.\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - Event callback\r\n *\r\n * @param {object}   opts - Optional parameters\r\n *\r\n * @returns {object} The output object.\r\n */\r\nconst s_GET_TYPE = (output, name, callback, opts) =>\r\n{\r\n   const events = opts.events;\r\n\r\n   if (events)\r\n   {\r\n      const handlers = events[name];\r\n\r\n      if (Array.isArray(handlers))\r\n      {\r\n         for (const handler of handlers)\r\n         {\r\n            if (handler.options.type > output.type)\r\n            {\r\n               output.type = handler.options.type;\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   return output;\r\n};\r\n\r\n/**\r\n * The reducing API that tests if an event name is guarded. Any event data of a give event name can have the guarded\r\n * state set. If so the event name will be added to the output names array and `output.guarded` set to true.\r\n *\r\n * @param {object}   output - The output object.\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - Event callback\r\n *\r\n * @param {object}   opts - Optional parameters\r\n *\r\n * @returns {object} The output object.\r\n */\r\nconst s_IS_GUARDED = (output, name, callback, opts) =>\r\n{\r\n   const events = opts.events;\r\n\r\n   if (events)\r\n   {\r\n      const handlers = events[name];\r\n\r\n      if (Array.isArray(handlers))\r\n      {\r\n         for (const handler of handlers)\r\n         {\r\n            if (handler.options.guard)\r\n            {\r\n                output.names.push(name);\r\n                output.guarded = true;\r\n                return output;\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   return output;\r\n};\r\n\r\n/**\r\n * The reducing API that removes a callback from the `events` object.\r\n *\r\n * @param {Events}   events - Events object\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - Event callback\r\n *\r\n * @param {object}   opts - Optional parameters\r\n *\r\n * @returns {void|Events} Events object\r\n */\r\nconst s_OFF_API = (events, name, callback, opts) =>\r\n{\r\n   /* c8 ignore next 1 */\r\n   if (!events) { return; }\r\n\r\n   const context = opts.context, listeners = opts.listeners;\r\n   let i = 0, names;\r\n\r\n   // Delete all event listeners and \"drop\" events.\r\n   if (!name && !context && !callback)\r\n   {\r\n      for (names = Utils.objectKeys(listeners); i < names.length; i++)\r\n      {\r\n         listeners[names[i]].cleanup();\r\n      }\r\n      return;\r\n   }\r\n\r\n   names = name ? [name] : Utils.objectKeys(events);\r\n\r\n   for (; i < names.length; i++)\r\n   {\r\n      name = names[i];\r\n      const handlers = events[name];\r\n\r\n      // Bail out if there are no events stored.\r\n      if (!handlers) { break; }\r\n\r\n      // Find any remaining events.\r\n      const remaining = [];\r\n      for (let j = 0; j < handlers.length; j++)\r\n      {\r\n         const handler = handlers[j];\r\n         if (callback && callback !== handler.callback && callback !== handler.callback._callback ||\r\n          context && context !== handler.context)\r\n         {\r\n            remaining.push(handler);\r\n         }\r\n         else\r\n         {\r\n            const listening = handler.listening;\r\n            if (listening) { listening.off(name, callback); }\r\n         }\r\n      }\r\n\r\n      // Replace events if there are any remaining.  Otherwise, clean up.\r\n      if (remaining.length)\r\n      {\r\n         events[name] = remaining;\r\n      }\r\n      else\r\n      {\r\n         delete events[name];\r\n      }\r\n   }\r\n\r\n   return events;\r\n};\r\n\r\n/**\r\n * The reducing API that adds a callback to the `events` object.\r\n *\r\n * @param {Events}   events - Events object\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - Event callback\r\n *\r\n * @param {object}   opts - Optional parameters\r\n *\r\n * @returns {Events} Events object.\r\n */\r\nconst s_ON_API = (events, name, callback, opts) =>\r\n{\r\n   if (callback)\r\n   {\r\n      const handlers = events[name] || (events[name] = []);\r\n      const context = opts.context, ctx = opts.ctx, listening = opts.listening;\r\n\r\n      // Make a copy of options.\r\n      const options = JSON.parse(JSON.stringify(opts.options));\r\n\r\n      // Ensure that guard is set.\r\n      options.guard = typeof options.guard === 'boolean' ? options.guard : false;\r\n\r\n      // Make sure options.type is set.\r\n      switch (options.type)\r\n      {\r\n         case 'sync':\r\n            options.type = 1;\r\n            break;\r\n         case 'async':\r\n            options.type = 2;\r\n            break;\r\n         default:\r\n            options.type = 0;\r\n            break;\r\n      }\r\n\r\n      if (listening) { listening.incrementCount(); }\r\n\r\n      handlers.push({ callback, context, ctx: context || ctx, options, listening });\r\n   }\r\n   return events;\r\n};\r\n\r\n/**\r\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\r\n * callback` and jQuery-style event maps `{event: callback}`).\r\n *\r\n * @param {Function} iteratee - Trigger API\r\n *\r\n * @param {Function} iterateeTarget - Internal function which is dispatched to.\r\n *\r\n * @param {Events|{}}   events - Array of stored event callback data.\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - callback\r\n *\r\n * @param {object}   opts - Optional parameters\r\n *\r\n * @returns {*} The results of the callback if any.\r\n */\r\nconst s_RESULTS_TARGET_API = (iteratee, iterateeTarget, events, name, callback, opts) =>\r\n{\r\n   let results = void 0;\r\n   let i = 0, names;\r\n\r\n   // Handle the case of multiple events being triggered. The potential results of each event & callbacks must be\r\n   // processed into a single array of results.\r\n   if (name && Utils.eventSplitter.test(name))\r\n   {\r\n      // Handle space-separated event names by delegating them individually.\r\n      for (names = name.split(Utils.eventSplitter); i < names.length; i++)\r\n      {\r\n         const result = iteratee(iterateeTarget, events, names[i], callback, opts);\r\n\r\n         // Determine type of `results`; 0: undefined, 1: single value, 2: an array of values.\r\n         const resultsType = Array.isArray(results) ? 2 : results !== void 0 ? 1 : 0;\r\n\r\n         // Handle an array result depending on existing results value.\r\n         if (Array.isArray(result))\r\n         {\r\n            switch (resultsType)\r\n            {\r\n               case 0:\r\n                  // Simply set results.\r\n                  results = result;\r\n                  break;\r\n               case 1:\r\n                  // Create a new array from existing results then concat the new result array.\r\n                  results = [results].concat(result);\r\n                  break;\r\n               case 2:\r\n                  // `results` is already an array so concat the new result array.\r\n                  results = results.concat(result);\r\n                  break;\r\n            }\r\n         }\r\n         else if (result !== void 0)\r\n         {\r\n            switch (resultsType)\r\n            {\r\n               case 0:\r\n                  // Simply set results.\r\n                  results = result;\r\n                  break;\r\n               case 1: {\r\n                  // Create a new array from existing results then push the new result value.\r\n                  const newArray = [results];\r\n                  newArray.push(result);\r\n                  results = newArray;\r\n                  break;\r\n               }\r\n               case 2:\r\n                  // `results` is already an array so push the new result array.\r\n                  results.push(result);\r\n                  break;\r\n            }\r\n         }\r\n      }\r\n   }\r\n   else\r\n   {\r\n      // Just single event.\r\n      results = iteratee(iterateeTarget, events, name, callback, opts);\r\n   }\r\n\r\n   return results;\r\n};\r\n\r\n/**\r\n * Handles triggering the appropriate event callbacks.\r\n *\r\n * @param {Function} iterateeTarget - Internal function which is dispatched to.\r\n *\r\n * @param {Events}   objEvents - Array of stored event callback data.\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - callback\r\n *\r\n * @param {*[]}      args - Arguments supplied to a trigger method.\r\n *\r\n * @returns {*} The results from the triggered event.\r\n */\r\nconst s_TRIGGER_API = (iterateeTarget, objEvents, name, callback, args) =>\r\n{\r\n   let result;\r\n\r\n   if (objEvents)\r\n   {\r\n      const events = objEvents[name];\r\n      let allEvents = objEvents.all;\r\n      if (events && allEvents) { allEvents = allEvents.slice(); }\r\n      if (events) { result = iterateeTarget(events, args); }\r\n      if (allEvents) { result = iterateeTarget(allEvents, [name].concat(args)); }\r\n   }\r\n\r\n   return result;\r\n};\r\n\r\n/**\r\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\r\n * cases speedy (most internal Backbone events have 3 arguments).\r\n *\r\n * @param {EventData[]} events - Array of stored event callback data.\r\n *\r\n * @param {*[]}         args - Event argument array\r\n */\r\nconst s_TRIGGER_EVENTS = (events, args) =>\r\n{\r\n   let ev, i = -1;\r\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\r\n\r\n   switch (args.length)\r\n   {\r\n      case 0:\r\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx); }\r\n         return;\r\n      case 1:\r\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1); }\r\n         return;\r\n      case 2:\r\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2); }\r\n         return;\r\n      case 3:\r\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); }\r\n         return;\r\n      default:\r\n         while (++i < l) { (ev = events[i]).callback.apply(ev.ctx, args); }\r\n         return;\r\n   }\r\n};\r\n\r\n/**\r\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\r\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method uses ES6 Promises and adds\r\n * any returned results to an array which is added to a Promise.all construction which passes back a Promise which\r\n * waits until all Promises complete. Any target invoked may return a Promise or any result. This is very useful to\r\n * use for any asynchronous operations.\r\n *\r\n * @param {EventData[]} events - Array of stored event callback data.\r\n *\r\n * @param {*[]}         args - Arguments supplied to `triggerAsync`.\r\n *\r\n * @returns {Promise<void|*|*[]>} A Promise of the results from the triggered event.\r\n */\r\nconst s_TRIGGER_ASYNC_EVENTS = async (events, args) =>\r\n{\r\n   let ev, i = -1;\r\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\r\n\r\n   const results = [];\r\n\r\n   switch (args.length)\r\n   {\r\n      case 0:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.call(ev.ctx);\r\n\r\n            // If we received a valid result add it to the promises array.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n\r\n      case 1:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.call(ev.ctx, a1);\r\n\r\n            // If we received a valid result add it to the promises array.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n\r\n      case 2:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\r\n\r\n            // If we received a valid result add it to the promises array.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n\r\n      case 3:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\r\n\r\n            // If we received a valid result add it to the promises array.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n\r\n      default:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.apply(ev.ctx, args);\r\n\r\n            // If we received a valid result add it to the promises array.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n   }\r\n\r\n   // If there are multiple results then use Promise.all otherwise Promise.resolve. Filter out any undefined results.\r\n   return results.length > 1 ? Promise.all(results).then((values) =>\r\n   {\r\n      const filtered = values.filter((entry) => entry !== void 0);\r\n      switch (filtered.length)\r\n      {\r\n         case 0: return void 0;\r\n         case 1: return filtered[0];\r\n         default: return filtered;\r\n      }\r\n   }) : results.length === 1 ? results[0] : void 0;\r\n};\r\n\r\n/**\r\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\r\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method synchronously passes back a\r\n * single value or an array with all results returned by any invoked targets.\r\n *\r\n * @param {EventData[]} events - Array of stored event callback data.\r\n *\r\n * @param {*[]}         args - Arguments supplied to `triggerSync`.\r\n *\r\n * @returns {void|*|*[]} The results from the triggered event.\r\n */\r\nconst s_TRIGGER_SYNC_EVENTS = (events, args) =>\r\n{\r\n   let ev, i = -1;\r\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\r\n\r\n   const results = [];\r\n\r\n   switch (args.length)\r\n   {\r\n      case 0:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.call(ev.ctx);\r\n\r\n            // If we received a valid result return immediately.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n      case 1:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.call(ev.ctx, a1);\r\n\r\n            // If we received a valid result return immediately.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n      case 2:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\r\n\r\n            // If we received a valid result return immediately.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n      case 3:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\r\n\r\n            // If we received a valid result return immediately.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n      default:\r\n         while (++i < l)\r\n         {\r\n            const result = (ev = events[i]).callback.apply(ev.ctx, args);\r\n\r\n            // If we received a valid result return immediately.\r\n            if (result !== void 0) { results.push(result); }\r\n         }\r\n         break;\r\n   }\r\n\r\n   // Return the results array if there are more than one or just a single result.\r\n   return results.length > 1 ? results : results.length === 1 ? results[0] : void 0;\r\n};\r\n\r\n/**\r\n * A try-catch guarded function. Used when attempting to invoke `isGuarded` from an other eventbus / context via\r\n * `listenTo`.\r\n *\r\n * @param {object}         obj - Event target / context\r\n *\r\n * @param {string|object}  name - Event name(s) or event map.\r\n *\r\n * @param {object}         data - Output data.\r\n *\r\n * @returns {boolean} Any error if thrown.\r\n */\r\nconst s_TRY_CATCH_IS_GUARDED = (obj, name, data = {}) =>\r\n{\r\n   let guarded = false;\r\n\r\n   try\r\n   {\r\n      const result = obj.isGuarded(name, data);\r\n      if (typeof result === 'boolean') { guarded = result; }\r\n   }\r\n   catch (err)\r\n   {\r\n      guarded = false;\r\n      data.names = [];\r\n      data.guarded = false;\r\n   }\r\n\r\n   return guarded;\r\n};\r\n\r\n/**\r\n * A try-catch guarded #on function, to prevent poisoning the global `_listening` variable. Used when attempting to\r\n * invoke `on` from an other eventbus / context via `listenTo`.\r\n *\r\n * @param {object}            obj - Event target / context\r\n *\r\n * @param {string|object}     name - Event name(s) or event map.\r\n *\r\n * @param {Function|object}   callback - Event callback function or context for event map.\r\n *\r\n * @param {object}            [context] - Event context\r\n *\r\n * @returns {Error} Any error if thrown.\r\n */\r\nconst s_TRY_CATCH_ON = (obj, name, callback, context) =>\r\n{\r\n   try\r\n   {\r\n      obj.on(name, callback, context);\r\n   }\r\n   catch (err)\r\n   {\r\n      return err;\r\n   }\r\n};\r\n\r\n/**\r\n * Generate a unique integer ID (unique within the entire client session).\r\n *\r\n * @type {number} - unique ID counter.\r\n */\r\nlet idCounter = 0;\r\n\r\n/**\r\n * Creates a new unique ID with a given prefix\r\n *\r\n * @param {string}   prefix - An optional prefix to add to unique ID.\r\n *\r\n * @returns {string} A new unique ID with a given prefix.\r\n */\r\nconst s_UNIQUE_ID = (prefix = '') =>\r\n{\r\n   const id = `${++idCounter}`;\r\n   return prefix ? `${prefix}${id}` /* c8 ignore next */ : id;\r\n};\r\n","import * as Utils     from './utils.js';\r\n\r\n/**\r\n * EventbusProxy provides a protected proxy of another Eventbus instance.\r\n *\r\n * The main use case of EventbusProxy is to allow indirect access to an eventbus. This is handy when it comes to\r\n * managing the event lifecycle for a plugin system. When a plugin is added it could receive a callback, perhaps named\r\n * `onPluginLoaded`, which contains an EventbusProxy instance rather than the direct eventbus. This EventbusProxy\r\n * instance is associated in the management system controlling plugin lifecycle. When a plugin is removed / unloaded the\r\n * management system can automatically unregister all events for the plugin without requiring the plugin author doing it\r\n * correctly if they had full control. IE This allows to plugin system to guarantee no dangling listeners.\r\n *\r\n * EventbusProxy provides the on / off, before, once, and trigger methods with the same signatures as found in\r\n * Eventbus. However, the proxy tracks all added event bindings which is used to proxy between the target\r\n * eventbus which is passed in from the constructor. All registration methods (on / off / once) proxy. In addition\r\n * there is a `destroy` method which will unregister all of proxied events and remove references to the managed\r\n * eventbus. Any further usage of a destroyed EventbusProxy instance results in a ReferenceError thrown.\r\n *\r\n * Finally the EventbusProxy only allows events registered through it to be turned off providing a buffer between\r\n * any consumers such that they can not turn off other registrations made on the eventbus or other proxy instances.\r\n */\r\nexport default class EventbusProxy\r\n{\r\n   /**\r\n    * Stores the target eventbus.\r\n    *\r\n    * @type {Eventbus}\r\n    * @private\r\n    */\r\n   #eventbus;\r\n\r\n   /**\r\n    * Stores all proxied event bindings.\r\n    *\r\n    * @type {Events|{}}\r\n    * @private\r\n    */\r\n   #events;\r\n\r\n   /**\r\n    * Creates the event proxy with an existing instance of Eventbus.\r\n    *\r\n    * @param {Eventbus}   eventbus - The target eventbus instance.\r\n    */\r\n   constructor(eventbus)\r\n   {\r\n      this.#eventbus = eventbus;\r\n\r\n      Object.seal(this);\r\n   }\r\n\r\n   /**\r\n    * Just like `on`, but causes the bound callback to fire several times up to the count specified before being\r\n    * removed. When multiple events are passed in using the space separated syntax, the event\r\n    * will fire count times for every event you passed in, not once for a combination of all events.\r\n    *\r\n    * @param {number}            count - Number of times the function will fire before being removed.\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @param {object}            [context] - Event context\r\n    *\r\n    * @param {ProxyOnOptions}    [options] - Event registration options.\r\n    *\r\n    * @returns {EventbusProxy} This EventbusProxy instance.\r\n    */\r\n   before(count, name, callback, context = void 0, options = {})\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\r\n\r\n      const data = {};\r\n      if (this.#eventbus.isGuarded(name, data))\r\n      {\r\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}` +\r\n          `- before() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\r\n         return this;\r\n      }\r\n\r\n      // Map the event into a `{event: beforeWrapper}` object.\r\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count, after: this.off.bind(this) });\r\n\r\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\r\n\r\n      return this.on(events, callback, context, options);\r\n   }\r\n\r\n   /**\r\n    * Creates an EventbusProxy wrapping the backing Eventbus instance. An EventbusProxy proxies events allowing all\r\n    * listeners added to be easily removed from the wrapped Eventbus.\r\n    *\r\n    * @returns {EventbusProxy} A new EventbusProxy for this eventbus.\r\n    */\r\n   createProxy()\r\n   {\r\n      return new EventbusProxy(this.#eventbus);\r\n   }\r\n\r\n   /**\r\n    * Unregisters all proxied events from the target eventbus and removes any local references. All subsequent calls\r\n    * after `destroy` has been called result in a ReferenceError thrown.\r\n    */\r\n   destroy()\r\n   {\r\n      if (this.#eventbus !== null)\r\n      {\r\n         this.off();\r\n      }\r\n\r\n      this.#events = void 0;\r\n\r\n      this.#eventbus = null;\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for all events from the proxied eventbus yielding an array with event name, callback function,\r\n    * and event context.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *entries(regex = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      for (const entry of this.#eventbus.entries(regex))\r\n      {\r\n         yield entry;\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns the current proxied eventbus event count.\r\n    *\r\n    * @returns {number} Returns the current proxied event count.\r\n    */\r\n   get eventCount()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.eventCount;\r\n   }\r\n\r\n   /**\r\n    * Returns the current proxied eventbus callback count.\r\n    *\r\n    * @returns {number} Returns the current proxied callback count.\r\n    */\r\n   get callbackCount()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.callbackCount;\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for the event names / keys of proxied eventbus event listeners.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *keys(regex = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      for (const entry of this.#eventbus.keys(regex))\r\n      {\r\n         yield entry;\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for the event names / keys of registered event listeners along with event options.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *keysWithOptions(regex = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      for (const entry of this.#eventbus.keysWithOptions(regex))\r\n      {\r\n         yield entry;\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns whether this EventbusProxy has already been destroyed.\r\n    *\r\n    * @returns {boolean} Is destroyed state.\r\n    */\r\n   get isDestroyed()\r\n   {\r\n      return this.#eventbus === null;\r\n   }\r\n\r\n   /**\r\n    * Returns the target eventbus name.\r\n    *\r\n    * @returns {string} The target eventbus name.\r\n    */\r\n   get name()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      return `proxy-${this.#eventbus.name}`;\r\n   }\r\n\r\n   /**\r\n    * Returns the current proxied event count.\r\n    *\r\n    * @returns {number} Returns the current proxied event count.\r\n    */\r\n   get proxyEventCount()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      if (!this.#events) { return 0; }\r\n\r\n      return Object.keys(this.#events).length;\r\n   }\r\n\r\n   /**\r\n    * Returns the current proxied callback count.\r\n    *\r\n    * @returns {number} Returns the current proxied callback count.\r\n    */\r\n   get proxyCallbackCount()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      if (!this.#events) { return 0; }\r\n\r\n      let count = 0;\r\n\r\n      for (const name in this.#events) { count += this.#events[name].length; }\r\n\r\n      return count;\r\n   }\r\n\r\n   /**\r\n    * Returns the options of an event name.\r\n    *\r\n    * @param {string}   name - Event name(s) to verify.\r\n    *\r\n    * @returns {DataOutOptions} The event options.\r\n    */\r\n   getOptions(name)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.getOptions(name);\r\n   }\r\n\r\n   /**\r\n    * Returns the trigger type of an event name.\r\n    * Note: if trigger type is not set then undefined is returned for type otherwise 'sync' or 'async' is returned.\r\n    *\r\n    * @param {string}   name - Event name(s) to verify.\r\n    *\r\n    * @returns {string|undefined} The trigger type.\r\n    */\r\n   getType(name)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.getType(name);\r\n   }\r\n\r\n   /**\r\n    * Returns whether an event name is guarded.\r\n    *\r\n    * @param {string|object}  name - Event name(s) or event map to verify.\r\n    *\r\n    * @param {object}         [data] - Stores the output of which names are guarded.\r\n    *\r\n    * @returns {boolean} Whether the given event name is guarded.\r\n    */\r\n   isGuarded(name, data = {})\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.isGuarded(name, data);\r\n   }\r\n\r\n   /**\r\n    * Remove a previously-bound proxied event binding.\r\n    *\r\n    * Please see {@link Eventbus#off}.\r\n    *\r\n    * @param {string|object}  [name] - Event name(s) or event map.\r\n    *\r\n    * @param {Function}       [callback] - Event callback function\r\n    *\r\n    * @param {object}         [context] - Event context\r\n    *\r\n    * @returns {EventbusProxy} This EventbusProxy\r\n    */\r\n   off(name = void 0, callback = void 0, context = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      this.#events = Utils.eventsAPI(s_OFF_API, this.#events || {}, name, callback, {\r\n         context,\r\n         eventbus: this.#eventbus,\r\n      });\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\r\n    * large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or\r\n    * \"change:selection\".\r\n    *\r\n    * Please see {@link Eventbus#on}.\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @param {object}            [context] - Event context.\r\n    *\r\n    * @param {ProxyOnOptions}    [options] - Event registration options.\r\n    *\r\n    * @returns {EventbusProxy} This EventbusProxy\r\n    */\r\n   on(name, callback, context = void 0, options = {})\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      if (options == null || options.constructor !== Object)   // eslint-disable-line eqeqeq\r\n      {\r\n         throw new TypeError(`'options' must be an object literal.`);\r\n      }\r\n\r\n      const data = {};\r\n      if (this.#eventbus.isGuarded(name, data))\r\n      {\r\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}` +\r\n          `- on() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\r\n         return this;\r\n      }\r\n\r\n      // Hang onto the options as s_ON_API sets the context we need to pass to the eventbus in `opts.ctx`.\r\n      const opts = { context, ctx: this, options };\r\n\r\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback, opts);\r\n\r\n      this.#eventbus.on(name, callback, opts.ctx, options);\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\r\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\r\n    * will fire once for every event you passed in, not once for a combination of all events\r\n    *\r\n    * @param {string|object}     name - Event name(s) or event map.\r\n    *\r\n    * @param {Function|object}   callback - Event callback function or context for event map.\r\n    *\r\n    * @param {object}            context - Event context\r\n    *\r\n    * @param {ProxyOnOptions}    [options] - Event registration options.\r\n    *\r\n    * @returns {EventbusProxy} This EventbusProxy instance.\r\n    */\r\n   once(name, callback, context = void 0, options = {})\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      const data = {};\r\n      if (this.#eventbus.isGuarded(name, data))\r\n      {\r\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}` +\r\n          `- once() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\r\n         return this;\r\n      }\r\n\r\n      // Map the event into a `{event: beforeWrapper}` object.\r\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count: 1, after: this.off.bind(this) });\r\n\r\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\r\n\r\n      return this.on(events, callback, context, options);\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for all stored locally proxied events yielding an array with event name, callback\r\n    * function, and event context.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *proxyEntries(regex = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\r\n\r\n      if (!this.#events) { return; }\r\n\r\n      if (regex)\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            if (regex.test(name))\r\n            {\r\n               for (const event of this.#events[name])\r\n               {\r\n                  yield [name, event.callback, event.context, JSON.parse(JSON.stringify(event.options))];\r\n               }\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            for (const event of this.#events[name])\r\n            {\r\n               yield [name, event.callback, event.context, JSON.parse(JSON.stringify(event.options))];\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for the event names / keys of the locally proxied event names.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *proxyKeys(regex = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\r\n\r\n      if (!this.#events) { return; }\r\n\r\n      if (regex)\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            if (regex.test(name))\r\n            {\r\n               yield name;\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            yield name;\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for the event names / keys of the locally proxied event names with event options.\r\n    *\r\n    * Note: The event options returned will respect all of the event options from a registered event event on the main\r\n    * eventbus if applicable.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *proxyKeysWithOptions(regex = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\r\n\r\n      if (!this.#events) { return; }\r\n\r\n      if (regex)\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            if (regex.test(name))\r\n            {\r\n               yield [name, this.#eventbus.getOptions(name)];\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const name in this.#events)\r\n         {\r\n            yield [name, this.#eventbus.getOptions(name)];\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\r\n    * passed along to the event callbacks.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {EventbusProxy} This EventbusProxy.\r\n    */\r\n   trigger(name, ...args)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      this.#eventbus.trigger(name, ...args);\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\r\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\r\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {Promise<void|*|*[]>} A Promise returning any results.\r\n    */\r\n   triggerAsync(name, ...args)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.triggerAsync(name, ...args);\r\n   }\r\n\r\n   /**\r\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {EventbusProxy} This EventbusProxy.\r\n    */\r\n   triggerDefer(name, ...args)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      this.#eventbus.triggerDefer(name, ...args);\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\r\n    * value or in an array and passes it back to the callee in a synchronous manner.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {void|*|*[]} An Array of returned results.\r\n    */\r\n   triggerSync(name, ...args)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.triggerSync(name, ...args);\r\n   }\r\n}\r\n\r\n/**\r\n * The reducing API that removes a callback from the `events` object. And delegates invoking off to the eventbus\r\n * reference.\r\n *\r\n * @param {Events}   events - Events object\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - Event callback\r\n *\r\n * @param {object}   opts - Optional parameters\r\n *\r\n * @returns {void|Events} Events object\r\n */\r\nconst s_OFF_API = (events, name, callback, opts) =>\r\n{\r\n   /* c8 ignore next 1 */\r\n   if (!events) { return; }\r\n\r\n   const context = opts.context;\r\n   const eventbus = opts.eventbus;\r\n\r\n   const names = name ? [name] : Utils.objectKeys(events);\r\n\r\n   for (let i = 0; i < names.length; i++)\r\n   {\r\n      name = names[i];\r\n      const handlers = events[name];\r\n\r\n      // Bail out if there are no events stored.\r\n      if (!handlers) { break; }\r\n\r\n      // Find any remaining events.\r\n      const remaining = [];\r\n      for (let j = 0; j < handlers.length; j++)\r\n      {\r\n         const handler = handlers[j];\r\n\r\n         if ((callback && callback !== handler.callback && callback !== handler.callback._callback) ||\r\n          (context && context !== handler.context))\r\n         {\r\n            remaining.push(handler);\r\n            continue;\r\n         }\r\n\r\n         // Must explicitly remove the event by the stored full set of name, handler, context to ensure\r\n         // non-proxied event registrations are not removed.\r\n         /* c8 ignore next 1 */\r\n         eventbus.off(name, handler.callback || handler.callback._callback, handler.context || handler.ctx);\r\n      }\r\n\r\n      // Replace events if there are any remaining.  Otherwise, clean up.\r\n      if (remaining.length)\r\n      {\r\n         events[name] = remaining;\r\n      }\r\n      else\r\n      {\r\n         // eventbus.off(name, callback, context);\r\n         delete events[name];\r\n      }\r\n   }\r\n\r\n   return events;\r\n};\r\n\r\n/**\r\n * The reducing API that adds a callback to the `events` object.\r\n *\r\n * @param {Events}   events - Events object\r\n *\r\n * @param {string}   name - Event name\r\n *\r\n * @param {Function} callback - Event callback\r\n *\r\n * @param {object}   opts - Optional parameters\r\n *\r\n * @returns {Events} Events object.\r\n */\r\nconst s_ON_API = (events, name, callback, opts) =>\r\n{\r\n   if (callback)\r\n   {\r\n      const handlers = events[name] || (events[name] = []);\r\n      const context = opts.context, ctx = opts.ctx;\r\n\r\n      // Make a copy of options.\r\n      const options = JSON.parse(JSON.stringify(opts.options));\r\n\r\n      // Ensure that guard is set.\r\n      options.guard = options.guard !== void 0 && typeof options.guard === 'boolean' ? options.guard : false;\r\n\r\n      // Ensure that type is set.\r\n      switch (options.type)\r\n      {\r\n         case 'sync':\r\n            options.type = 1;\r\n            break;\r\n         case 'async':\r\n            options.type = 2;\r\n            break;\r\n         default:\r\n            options.type = 0;\r\n            break;\r\n      }\r\n\r\n      // Set opts `ctx` as this is what we send to the eventbus.\r\n      opts.ctx = context || ctx;\r\n\r\n      handlers.push({ callback, context, ctx: opts.ctx, options });\r\n   }\r\n\r\n   return events;\r\n};\r\n","/**\r\n * EventbusSecure provides a secure wrapper around another Eventbus instance.\r\n *\r\n * The main use case of EventbusSecure is to provide a secure eventbus window for general public consumption. Only\r\n * events can be triggered, but not registered / unregistered.\r\n *\r\n * You must use the initialize method passing in an existing Eventbus instance as the eventbus reference is private.\r\n * In order to secure the eventbus from unwanted access there is no way to access the eventbus reference externally from\r\n * the EventbusSecure instance. The initialize method returns an {@link EventbusSecureObj} object which\r\n * contains two functions to control the secure eventbus externally; `destroy` and `setEventbus`. Expose to end\r\n * consumers just the `eventbusSecure` instance.\r\n */\r\nexport default class EventbusSecure\r\n{\r\n   /**\r\n    * Stores the target eventbus.\r\n    *\r\n    * @type {Eventbus}\r\n    * @private\r\n    */\r\n   #eventbus;\r\n\r\n   /**\r\n    * Stores a potentially alternate name instead of returning the wrapped Eventbus instance name.\r\n    *\r\n    * @type {string}\r\n    * @private\r\n    */\r\n   #name;\r\n\r\n   /**\r\n    * Creates the EventbusSecure instance with an existing instance of Eventbus. An object / EventbusSecureObj is\r\n    * returned with an EventbusSecure reference and two functions for controlling the underlying Eventbus reference.\r\n    *\r\n    * `destroy()` will destroy the underlying Eventbus reference.\r\n    * `setEventbus(<eventbus>)` will set the underlying reference.\r\n    *\r\n    * @param {Eventbus|EventbusProxy}  eventbus - The target eventbus instance.\r\n    *\r\n    * @param {string}                  [name] - If a name is provided this will be used instead of eventbus name.\r\n    *\r\n    * @returns {EventbusSecureObj} The control object which contains an EventbusSecure reference and control functions.\r\n    */\r\n   static initialize(eventbus, name = void 0)\r\n   {\r\n      if (name !== void 0 && typeof name !== 'string') { throw new TypeError(`'name' is not a string.`); }\r\n\r\n      const eventbusSecure = new EventbusSecure();\r\n      eventbusSecure.#eventbus = eventbus;\r\n      eventbusSecure.#name = name === void 0 ? eventbus.name : name;\r\n      Object.seal(eventbusSecure);\r\n\r\n      return {\r\n         destroy: function()\r\n         {\r\n            if (!eventbusSecure.isDestroyed)\r\n            {\r\n               eventbusSecure.#eventbus = null;\r\n\r\n               if (this) { this.eventbusSecure = void 0; }\r\n            }\r\n         },\r\n\r\n         setEventbus: function(eventbus, name = void 0)\r\n         {\r\n            if (name !== void 0 && typeof name !== 'string') { throw new TypeError(`'name' is not a string.`); }\r\n\r\n            if (!eventbusSecure.isDestroyed)\r\n            {\r\n               // Adopt the new eventbus name as the current name set matches the wrapped eventbus.\r\n               if (name === void 0 && eventbusSecure.#name === eventbusSecure.#eventbus.name)\r\n               {\r\n                  eventbusSecure.#name = eventbus.name;\r\n               }\r\n               else if (name !== void 0)\r\n               {\r\n                  eventbusSecure.#name = name;\r\n               }\r\n\r\n               eventbusSecure.#eventbus = eventbus;\r\n            }\r\n         },\r\n\r\n         eventbusSecure\r\n      };\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for the event names / keys of secured eventbus event listeners.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *keys(regex = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      for (const entry of this.#eventbus.keys(regex))\r\n      {\r\n         yield entry;\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable for the event names / keys of registered event listeners along with event options.\r\n    *\r\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\r\n    *\r\n    * @yields\r\n    */\r\n   *keysWithOptions(regex = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      for (const entry of this.#eventbus.keysWithOptions(regex))\r\n      {\r\n         yield entry;\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns whether this instance has already been destroyed.\r\n    *\r\n    * @returns {boolean} Is destroyed state.\r\n    */\r\n   get isDestroyed()\r\n   {\r\n      return this.#eventbus === null;\r\n   }\r\n\r\n   /**\r\n    * Returns the name associated with this instance.\r\n    *\r\n    * @returns {string} The target eventbus name.\r\n    */\r\n   get name()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      return this.#name;\r\n   }\r\n\r\n   /**\r\n    * Returns the options of an event name.\r\n    *\r\n    * @param {string}   name - Event name(s) to verify.\r\n    *\r\n    * @returns {DataOutOptions} The event options.\r\n    */\r\n   getOptions(name)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.getOptions(name);\r\n   }\r\n\r\n   /**\r\n    * Returns the trigger type of an event name.\r\n    * Note: if trigger type is not set then undefined is returned for type otherwise 'sync' or 'async' is returned.\r\n    *\r\n    * @param {string}   name - Event name(s) to verify.\r\n    *\r\n    * @returns {string|undefined} The trigger type.\r\n    */\r\n   getType(name)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.getType(name);\r\n   }\r\n\r\n   /**\r\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\r\n    * passed along to the event callbacks.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {EventbusSecure} This instance.\r\n    */\r\n   trigger(name, ...args)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      this.#eventbus.trigger(name, ...args);\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\r\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\r\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {Promise<void|*|*[]>} A Promise to returning any results.\r\n    */\r\n   triggerAsync(name, ...args)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.triggerAsync(name, ...args);\r\n   }\r\n\r\n   /**\r\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {EventbusSecure} This EventbusProxy.\r\n    */\r\n   triggerDefer(name, ...args)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      this.#eventbus.triggerDefer(name, ...args);\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\r\n    * value or in an array and passes it back to the callee in a synchronous manner.\r\n    *\r\n    * @param {string}   name - Event name(s)\r\n    *\r\n    * @param {...*}     args - Additional arguments passed to the event function(s).\r\n    *\r\n    * @returns {void|*|*[]} An Array of returned results.\r\n    */\r\n   triggerSync(name, ...args)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\r\n\r\n      return this.#eventbus.triggerSync(name, ...args);\r\n   }\r\n}\r\n","import Eventbus                        from './Eventbus.js';\r\n\r\nexport { default as EventbusProxy }    from './EventbusProxy.js';\r\nexport { default as EventbusSecure }   from './EventbusSecure.js';\r\n\r\nexport default Eventbus;\r\n\r\n/**\r\n * Provides a main eventbus instance.\r\n *\r\n * @type {Eventbus}\r\n */\r\nexport const eventbus = new Eventbus('mainEventbus');\r\n\r\n/**\r\n * Provides an eventbus instance potentially for use with a plugin system.\r\n *\r\n * @type {Eventbus}\r\n */\r\nexport const pluginEventbus = new Eventbus('pluginEventbus');\r\n\r\n/**\r\n * Provides an eventbus instance potentially for use for testing.\r\n *\r\n * @type {Eventbus}\r\n */\r\nexport const testEventbus = new Eventbus('testEventbus');\r\n","/**\n * URL matching RegExp\n *\n * @type {RegExp}\n */\nconst s_URL_REGEX = /^(https?:\\/\\/|file:\\/\\/)/;\n\nexport default class ModuleLoader\n{\n   /**\n    * Loads an ES Module in the browser passing back an object containing info about the loading process.\n    *\n    * @param {object}      options - Options object.\n    *\n    * @param {string|URL}  options.modulepath - A module name, file path, or URL.\n    *\n    * @param {Function}    [options.resolveModule] - An optional function which resolves the import to set `instance`.\n    *\n    * @returns {Promise<{ModuleLoaderObj}>} The module / instance and data about the loading process.\n    */\n   static async load({ modulepath, resolveModule = void 0 } = {})\n   {\n      if (!(modulepath instanceof URL) && typeof modulepath !== 'string')\n      {\n         throw new TypeError(`'modulepath' is not a string or URL`);\n      }\n\n      if (resolveModule !== void 0 && typeof resolveModule !== 'function')\n      {\n         throw new TypeError(`'resolveModule' is not a function`);\n      }\n\n      const module = await import(modulepath);\n\n      const loadpath = modulepath instanceof URL ? modulepath.toString() : modulepath;\n\n      const type = `import-${modulepath instanceof URL ||\n      (typeof modulepath === 'string' && modulepath.match(s_URL_REGEX)) ? 'url' : 'path'}`;\n\n      const instance = resolveModule !== void 0 ? resolveModule(module) : module;\n\n      return { filepath: loadpath, instance, isESM: true, loadpath, module, modulepath, type };\n   }\n}\n","/**\r\n * Defines a class holding the data associated with a plugin including its instance.\r\n */\r\nexport default class PluginEntry\r\n{\r\n   /**\r\n    * Data describing the plugin, manager, and optional module data.\r\n    *\r\n    * @type {PluginData}\r\n    * @private\r\n    */\r\n   #data;\r\n\r\n   /**\r\n    * The plugin enabled state.\r\n    *\r\n    * @type {boolean}\r\n    * @private\r\n    */\r\n   #enabled;\r\n\r\n   /**\r\n    * The plugin name.\r\n    *\r\n    * @type {string}\r\n    * @private\r\n    */\r\n   #name;\r\n\r\n   /**\r\n    * Any stored import.meta data.\r\n    *\r\n    * @type {object}\r\n    * @private\r\n    */\r\n   #importmeta;\r\n\r\n   /**\r\n    * The loaded plugin instance.\r\n    *\r\n    * @type {object}\r\n    * @private\r\n    */\r\n   #instance;\r\n\r\n   /**\r\n    * An EventbusProxy associated with the plugin wrapping the plugin manager eventbus.\r\n    *\r\n    * @type {EventbusProxy}\r\n    * @private\r\n    */\r\n   #eventbusProxy;\r\n\r\n   /**\r\n    * Stores the proxied event names, callback functions, context and guarded state when this plugin is disabled.\r\n    *\r\n    * @type {Array<[string, Function, object, boolean]>}\r\n    * @private\r\n    */\r\n   #events;\r\n\r\n   /**\r\n    * Instantiates a PluginEntry.\r\n    *\r\n    * @param {string}      name - The plugin name.\r\n    *\r\n    * @param {PluginData}  data - Describes the plugin, manager, and optional module data.\r\n    *\r\n    * @param {object}      instance - The loaded plugin instance.\r\n    *\r\n    * @param {EventbusProxy}  eventbusProxy - The EventbusProxy associated with the plugin wrapping the plugin manager\r\n    *                                         eventbus.\r\n    */\r\n   constructor(name, data, instance, eventbusProxy = void 0)\r\n   {\r\n      this.#data = data;\r\n\r\n      this.#enabled = true;\r\n\r\n      this.#name = name;\r\n\r\n      this.#instance = instance;\r\n\r\n      this.#eventbusProxy = eventbusProxy;\r\n   }\r\n\r\n   /**\r\n    * Get plugin data.\r\n    *\r\n    * @returns {PluginData} The associated PluginData.\r\n    */\r\n   get data() { return this.#data; }\r\n\r\n   /**\r\n    * Get enabled.\r\n    *\r\n    * @returns {boolean} Current enabled state.\r\n    */\r\n   get enabled() { return this.#enabled; }\r\n\r\n   /**\r\n    * Get any stored import.meta object.\r\n    *\r\n    * @returns {undefined|object} Any set import.meta info.\r\n    */\r\n   get importmeta() { return this.#importmeta; }\r\n\r\n   /**\r\n    * Reset will cleanup most resources for remove / reload. 'remove' should manually destroy #eventbusProxy.\r\n    */\r\n   reset()\r\n   {\r\n      try\r\n      {\r\n         this.#events = void 0;\r\n         this.#importmeta = void 0;\r\n\r\n         // Automatically remove any potential reference to a stored event proxy instance.\r\n         delete this.#instance._eventbus;\r\n      }\r\n      catch (err) { /* noop */ }\r\n   }\r\n\r\n   /**\r\n    * Set enabled.\r\n    *\r\n    * @param {boolean} enabled - New enabled state.\r\n    */\r\n   set enabled(enabled)\r\n   {\r\n      this.#enabled = enabled;\r\n\r\n      // If enabled and there are stored events then turn them on with the eventbus proxy.\r\n      if (enabled)\r\n      {\r\n         if (this.#eventbusProxy !== void 0 && Array.isArray(this.#events))\r\n         {\r\n            for (const event of this.#events)\r\n            {\r\n               this.#eventbusProxy.on(...event);\r\n            }\r\n\r\n            this.#events = void 0;\r\n         }\r\n      }\r\n      else // Store any proxied events and unregister the proxied events.\r\n      {\r\n         if (this.#eventbusProxy !== void 0)\r\n         {\r\n            this.#events = Array.from(this.#eventbusProxy.proxyEntries());\r\n            this.#eventbusProxy.off();\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Get associated EventbusProxy.\r\n    *\r\n    * @returns {EventbusProxy} Associated EventbusProxy.\r\n    */\r\n   get eventbusProxy() { return this.#eventbusProxy; }\r\n\r\n   /**\r\n    * Get plugin instance.\r\n    *\r\n    * @returns {object} The plugin instance.\r\n    */\r\n   get instance() { return this.#instance; }\r\n\r\n   /**\r\n    * Get plugin name.\r\n    *\r\n    * @returns {string} Plugin name.\r\n    */\r\n   get name() { return this.#name; }\r\n\r\n\r\n   /**\r\n    * Set associated EventbusProxy.\r\n    *\r\n    * @param {EventbusProxy} eventbusProxy - EventbusProxy instance to associate.\r\n    */\r\n   set eventbusProxy(eventbusProxy) { this.#eventbusProxy = eventbusProxy; }\r\n\r\n   /**\r\n    * Set any associated import.meta data.\r\n    *\r\n    * @param {object} importmeta - import.meta data.\r\n    */\r\n   set importmeta(importmeta) { this.#importmeta = importmeta; }\r\n\r\n   /**\r\n    * Set plugin instance.\r\n    *\r\n    * @param {object} instance - The plugin instance.\r\n    */\r\n   set instance(instance) { this.#instance = instance; }\r\n}\r\n","/**\n * Provides common object manipulation utilities including depth traversal, obtaining accessors, safely setting values /\n * equality tests, and validation.\n */\n\nconst s_TAG_MAP = '[object Map]';\nconst s_TAG_SET = '[object Set]';\nconst s_TAG_STRING = '[object String]';\n\n/**\n * @typedef {object} ValidationEntry - Provides data for a validation check.\n *\n * @property {string}               [type] - Optionally tests with a typeof check.\n *\n * @property {Array<*>|Function|Set<*>}  [expected] - Optional array, function, or set of expected values to test\n * against.\n *\n * @property {string}               [message] - Optional message to include.\n *\n * @property {boolean}              [required=true] - When false if the accessor is missing validation is skipped.\n *\n * @property {boolean}              [error=true] - When true and error is thrown otherwise a boolean is returned.\n */\n\n/**\n * Freezes all entries traversed that are objects including entries in arrays.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {string[]}       skipFreezeKeys - An array of strings indicating keys of objects to not freeze.\n *\n * @returns {object|Array} The frozen object.\n */\nexport function deepFreeze(data, skipFreezeKeys = [])\n{\n   /* istanbul ignore if */\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n\n   /* istanbul ignore if */\n   if (!Array.isArray(skipFreezeKeys)) { throw new TypeError(`'skipFreezeKeys' is not an 'array'.`); }\n\n   return _deepFreeze(data, skipFreezeKeys);\n}\n\n/**\n * Performs a naive depth traversal of an object / array. The data structure _must not_ have circular references.\n * The result of the callback function is used to modify in place the given data.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {Function}       func - A callback function to process leaf values in children arrays or object members.\n *\n * @param {boolean}        modify - If true then the result of the callback function is used to modify in place\n *                                  the given data.\n *\n * @returns {*} The data object.\n */\nexport function depthTraverse(data, func, modify = false)\n{\n   /* istanbul ignore if */\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n\n   /* istanbul ignore if */\n   if (typeof func !== 'function') { throw new TypeError(`'func' is not a 'function'.`); }\n\n   return _depthTraverse(data, func, modify);\n}\n\n/**\n * Returns a list of accessor keys by traversing the given object.\n *\n * @param {object}   data - An object to traverse for accessor keys.\n *\n * @returns {string[]} Accessor list.\n */\nexport function getAccessorList(data)\n{\n   if (typeof data !== 'object') { throw new TypeError(`getAccessorList error: 'data' is not an 'object'.`); }\n\n   return _getAccessorList(data);\n}\n\n/**\n * Tests for whether an object is iterable.\n *\n * @param {object} object - An object.\n *\n * @returns {boolean} Whether object is iterable.\n */\nexport function isIterable(object)\n{\n   if (object === null || object === void 0 || typeof object !== 'object') { return false; }\n\n   return typeof object[Symbol.iterator] === 'function';\n}\n\n/**\n * Tests for whether an object is async iterable.\n *\n * @param {object} object - An object.\n *\n * @returns {boolean} Whether object is async iterable.\n */\nexport function isIterableAsync(object)\n{\n   if (object === null || object === void 0 || typeof object !== 'object') { return false; }\n\n   return typeof object[Symbol.asyncIterator] === 'function';\n}\n\n/**\n * Tests for whether object is not null and a typeof object.\n *\n * @param {object} object - An object.\n *\n * @returns {boolean} Is it an object.\n */\nexport function isObject(object)\n{\n   return object !== null && typeof object === 'object';\n}\n\n/**\n * Safely returns keys on an object or an empty array if not an object.\n *\n * @param {object} object - An object.\n *\n * @returns {string[]} Object keys\n */\nexport function objectKeys(object)\n{\n   return object !== null && typeof object === 'object' ? Object.keys(object) : [];\n}\n\n/**\n * Safely returns an objects size. Note for String objects unicode is not taken into consideration.\n *\n * @param {object} object - An object.\n *\n * @returns {number} Size of object.\n */\nexport function objectSize(object)\n{\n   if (object === void 0 || object === null || typeof object !== 'object') { return 0; }\n\n   const tag = Object.prototype.toString.call(object);\n\n   if (tag === s_TAG_MAP || tag === s_TAG_SET) { return object.size; }\n\n   if (tag === s_TAG_STRING) { return object.length; }\n\n   return Object.keys(object).length;\n}\n\n/**\n * Provides a way to safely access an objects data / entries given an accessor string which describes the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk.\n *\n * @param {object}   data - An object to access entry data.\n *\n * @param {string}   accessor - A string describing the entries to access.\n *\n * @param {*}        defaultValue - (Optional) A default value to return if an entry for accessor is not found.\n *\n * @returns {object} The data object.\n */\nexport function safeAccess(data, accessor, defaultValue = void 0)\n{\n   if (typeof data !== 'object') { return defaultValue; }\n   if (typeof accessor !== 'string') { return defaultValue; }\n\n   const access = accessor.split('.');\n\n   // Walk through the given object by the accessor indexes.\n   for (let cntr = 0; cntr < access.length; cntr++)\n   {\n      // If the next level of object access is undefined or null then return the empty string.\n      if (typeof data[access[cntr]] === 'undefined' || data[access[cntr]] === null) { return defaultValue; }\n\n      data = data[access[cntr]];\n   }\n\n   return data;\n}\n\n/**\n * Provides a way to safely batch set an objects data / entries given an array of accessor strings which describe the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk. If value is an object the accessor will be used to access a target value from `value` which is\n * subsequently set to `data` by the given operation. If `value` is not an object it will be used as the target\n * value to set across all accessors.\n *\n * @param {object}         data - An object to access entry data.\n *\n * @param {Array<string>}  accessors - A string describing the entries to access.\n *\n * @param {object|*}       value - A new value to set if an entry for accessor is found.\n *\n * @param {string}         [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\n *                                             'set-undefined', 'sub'.\n *\n * @param {object|*}       [defaultAccessValue=0] - A new value to set if an entry for accessor is found.\n *\n *\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\n *                                          automatically.\n */\nexport function safeBatchSet(data, accessors, value, operation = 'set', defaultAccessValue = 0, createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`safeBatchSet Error: 'data' is not an 'object'.`); }\n   if (!Array.isArray(accessors)) { throw new TypeError(`safeBatchSet Error: 'accessors' is not an 'array'.`); }\n\n   if (typeof value === 'object')\n   {\n      accessors.forEach((accessor) =>\n      {\n         const targetValue = safeAccess(value, accessor, defaultAccessValue);\n         safeSet(data, accessor, targetValue, operation, createMissing);\n      });\n   }\n   else\n   {\n      accessors.forEach((accessor) =>\n      {\n         safeSet(data, accessor, value, operation, createMissing);\n      });\n   }\n}\n\n/**\n * Compares a source object and values of entries against a target object. If the entries in the source object match\n * the target object then `true` is returned otherwise `false`. If either object is undefined or null then false\n * is returned.\n *\n * @param {object}   source - Source object.\n *\n * @param {object}   target - Target object.\n *\n * @returns {boolean} True if equal.\n */\nexport function safeEqual(source, target)\n{\n   if (typeof source === 'undefined' || source === null || typeof target === 'undefined' || target === null)\n   {\n      return false;\n   }\n\n   const sourceAccessors = getAccessorList(source);\n\n   for (let cntr = 0; cntr < sourceAccessors.length; cntr++)\n   {\n      const accessor = sourceAccessors[cntr];\n\n      const sourceObjectValue = safeAccess(source, accessor);\n      const targetObjectValue = safeAccess(target, accessor);\n\n      if (sourceObjectValue !== targetObjectValue) { return false; }\n   }\n\n   return true;\n}\n\n/**\n * Provides a way to safely set an objects data / entries given an accessor string which describes the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk.\n *\n * @param {object}   data - An object to access entry data.\n *\n * @param {string}   accessor - A string describing the entries to access.\n *\n * @param {*}        value - A new value to set if an entry for accessor is found.\n *\n * @param {string}   [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\n *                                       'set-undefined', 'sub'.\n *\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\n *                                          automatically.\n *\n * @returns {boolean} True if successful.\n */\nexport function safeSet(data, accessor, value, operation = 'set', createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`safeSet Error: 'data' is not an 'object'.`); }\n   if (typeof accessor !== 'string') { throw new TypeError(`safeSet Error: 'accessor' is not a 'string'.`); }\n\n   const access = accessor.split('.');\n\n   // Walk through the given object by the accessor indexes.\n   for (let cntr = 0; cntr < access.length; cntr++)\n   {\n      // If data is an array perform validation that the accessor is a positive integer otherwise quit.\n      if (Array.isArray(data))\n      {\n         const number = (+access[cntr]);\n\n         if (!Number.isInteger(number) || number < 0) { return false; }\n      }\n\n      if (cntr === access.length - 1)\n      {\n         switch (operation)\n         {\n            case 'add':\n               data[access[cntr]] += value;\n               break;\n\n            case 'div':\n               data[access[cntr]] /= value;\n               break;\n\n            case 'mult':\n               data[access[cntr]] *= value;\n               break;\n\n            case 'set':\n               data[access[cntr]] = value;\n               break;\n\n            case 'set-undefined':\n               if (typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = value; }\n               break;\n\n            case 'sub':\n               data[access[cntr]] -= value;\n               break;\n         }\n      }\n      else\n      {\n         // If createMissing is true and the next level of object access is undefined then create a new object entry.\n         if (createMissing && typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = {}; }\n\n         // Abort if the next level is null or not an object and containing a value.\n         if (data[access[cntr]] === null || typeof data[access[cntr]] !== 'object') { return false; }\n\n         data = data[access[cntr]];\n      }\n   }\n\n   return true;\n}\n\n/**\n * Performs bulk setting of values to the given data object.\n *\n * @param {object}            data - The data object to set data.\n *\n * @param {object<string, *>} accessorValues - Object of accessor keys to values to set.\n *\n * @param {string}            [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set', 'sub';\n *                                                default (`set`).\n *\n * @param {boolean}           [createMissing=true] - If true missing accessor entries will be created as objects\n *                                                   automatically.\n */\nexport function safeSetAll(data, accessorValues, operation = 'set', createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n   if (typeof accessorValues !== 'object') { throw new TypeError(`'accessorValues' is not an 'object'.`); }\n\n   for (const accessor of Object.keys(accessorValues))\n   {\n      if (!accessorValues.hasOwnProperty(accessor)) { continue; } // eslint-disable-line no-prototype-builtins\n\n      safeSet(data, accessor, accessorValues[accessor], operation, createMissing);\n   }\n}\n\n/**\n * Performs bulk validation of data given an object, `validationData`, which describes all entries to test.\n *\n * @param {object}                           data - The data object to test.\n *\n * @param {object<string, ValidationEntry>}  validationData - Key is the accessor / value is a validation entry.\n *\n * @param {string}                           [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validate(data, validationData = {}, dataName = 'data')\n{\n   if (typeof data !== 'object') { throw new TypeError(`'${dataName}' is not an 'object'.`); }\n   if (typeof validationData !== 'object') { throw new TypeError(`'validationData' is not an 'object'.`); }\n\n   let result;\n\n   for (const key of Object.keys(validationData))\n   {\n      if (!validationData.hasOwnProperty(key)) { continue; } // eslint-disable-line no-prototype-builtins\n\n      const entry = validationData[key];\n\n      switch (entry.test)\n      {\n         case 'array':\n            result = validateArray(data, key, entry, dataName);\n            break;\n\n         case 'entry':\n            result = validateEntry(data, key, entry, dataName);\n            break;\n\n         case 'entry|array':\n            result = validateEntryOrArray(data, key, entry, dataName);\n            break;\n      }\n   }\n\n   return result;\n}\n\n/**\n * Validates all array entries against potential type and expected tests.\n *\n * @param {object}            data - The data object to test.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {object}            opts - Options object.\n *\n * @param {string}            [opts.type] - Tests with a typeof check.\n *\n * @param {Function|Set<*>}   [opts.expected] - Optional function or set of expected values to test against.\n *\n * @param {string}            [opts.message] - Optional message to include.\n *\n * @param {boolean}           [opts.required] - When false if the accessor is missing validation is skipped.\n *\n * @param {boolean}           [opts.error=true] - When true and error is thrown otherwise a boolean is returned.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateArray(data, accessor, { type = void 0, expected = void 0, message = void 0, required = true,\n error = true } = {}, dataName = 'data')\n{\n   const dataArray = safeAccess(data, accessor);\n\n   // A non-required entry is missing so return without validation.\n   if (!required && typeof dataArray === 'undefined') { return true; }\n\n   if (!Array.isArray(dataArray))\n   {\n      if (error)\n      {\n         throw _validateError(TypeError, `'${dataName}.${accessor}' is not an 'array'.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n\n   if (typeof type === 'string')\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (!(typeof dataArray[cntr] === type))\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(TypeError,\n                `'${dataName}.${accessor}[${cntr}]': '${dataEntryString}' is not a '${type}'.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n\n   // If expected is a function then test all array entries against the test function. If expected is a Set then\n   // test all array entries for inclusion in the set. Otherwise if expected is a string then test that all array\n   // entries as a `typeof` test against expected.\n   if (Array.isArray(expected))\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (!expected.includes(dataArray[cntr]))\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' is not an expected value: ${JSON.stringify(expected)}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n   else if (expected instanceof Set)\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (!expected.has(dataArray[cntr]))\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' is not an expected value: ${JSON.stringify(expected)}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n   else if (typeof expected === 'function')\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         try\n         {\n            const result = expected(dataArray[cntr]);\n\n            if (typeof result === 'undefined' || !result) { throw new Error(message); }\n         }\n         catch (err)\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' failed validation: ${err.message}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n\n   return true;\n}\n\n/**\n * Validates data entry with a typeof check and potentially tests against the values in any given expected set.\n *\n * @param {object}            data - The object data to validate.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {object}            opts - Options object\n *\n * @param {string}            [opts.type] - Tests with a typeof check.\n *\n * @param {Function|Set<*>}   [opts.expected] - Optional function or set of expected values to test against.\n *\n * @param {string}            [opts.message] - Optional message to include.\n *\n * @param {boolean}           [opts.required=true] - When false if the accessor is missing validation is skipped.\n *\n * @param {boolean}           [opts.error=true] - When true and error is thrown otherwise a boolean is returned.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateEntry(data, accessor, { type = void 0, expected = void 0, message = void 0, required = true,\n error = true } = {}, dataName = 'data')\n{\n   const dataEntry = safeAccess(data, accessor);\n\n   // A non-required entry is missing so return without validation.\n   if (!required && typeof dataEntry === 'undefined') { return true; }\n\n   if (type && typeof dataEntry !== type)\n   {\n      if (error)\n      {\n         throw _validateError(TypeError, `'${dataName}.${accessor}' is not a '${type}'.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n\n   if ((expected instanceof Set && !expected.has(dataEntry)) ||\n    (Array.isArray(expected) && !expected.includes(dataEntry)))\n   {\n      if (error)\n      {\n         const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\n\n         throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' is not an expected value: ${\n          JSON.stringify(expected)}.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n   else if (typeof expected === 'function')\n   {\n      try\n      {\n         const result = expected(dataEntry);\n\n         if (typeof result === 'undefined' || !result) { throw new Error(message); }\n      }\n      catch (err)\n      {\n         if (error)\n         {\n            const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\n\n            throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' failed to validate: ${\n             err.message}.`);\n         }\n         else\n         {\n            return false;\n         }\n      }\n   }\n\n   return true;\n}\n\n/**\n * Dispatches validation of data entry to string or array validation depending on data entry type.\n *\n * @param {object}            data - The data object to test.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {ValidationEntry}   [entry] - A validation entry.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateEntryOrArray(data, accessor, entry, dataName = 'data')\n{\n   const dataEntry = safeAccess(data, accessor);\n\n   let result;\n\n   if (Array.isArray(dataEntry))\n   {\n      result = validateArray(data, accessor, entry, dataName);\n   }\n   else\n   {\n      result = validateEntry(data, accessor, entry, dataName);\n   }\n\n   return result;\n}\n\n// Module private ---------------------------------------------------------------------------------------------------\n\n/**\n * Private implementation of depth traversal.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {string[]}       skipFreezeKeys - An array of strings indicating keys of objects to not freeze.\n *\n * @returns {*} The frozen object.\n * @ignore\n * @private\n */\nfunction _deepFreeze(data, skipFreezeKeys)\n{\n   if (Array.isArray(data))\n   {\n      for (let cntr = 0; cntr < data.length; cntr++) { _deepFreeze(data[cntr], skipFreezeKeys); }\n   }\n   else if (typeof data === 'object')\n   {\n      for (const key in data)\n      {\n         // eslint-disable-next-line no-prototype-builtins\n         if (data.hasOwnProperty(key) && !skipFreezeKeys.includes(key)) { _deepFreeze(data[key], skipFreezeKeys); }\n      }\n   }\n\n   return Object.freeze(data);\n}\n\n/**\n * Private implementation of depth traversal.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {Function}       func - A callback function to process leaf values in children arrays or object members.\n *\n * @param {boolean}        modify - If true then the result of the callback function is used to modify in place\n *                                  the given data.\n *\n * @returns {*} The data object.\n * @ignore\n * @private\n */\nfunction _depthTraverse(data, func, modify)\n{\n   if (modify)\n   {\n      if (Array.isArray(data))\n      {\n         for (let cntr = 0; cntr < data.length; cntr++)\n         {\n            data[cntr] = _depthTraverse(data[cntr], func, modify);\n         }\n      }\n      else if (typeof data === 'object')\n      {\n         for (const key in data)\n         {\n            // eslint-disable-next-line no-prototype-builtins\n            if (data.hasOwnProperty(key)) { data[key] = _depthTraverse(data[key], func, modify); }\n         }\n      }\n      else\n      {\n         data = func(data);\n      }\n   }\n   else\n   {\n      if (Array.isArray(data))\n      {\n         for (let cntr = 0; cntr < data.length; cntr++) { _depthTraverse(data[cntr], func, modify); }\n      }\n      else if (typeof data === 'object')\n      {\n         for (const key in data)\n         {\n            // eslint-disable-next-line no-prototype-builtins\n            if (data.hasOwnProperty(key)) { _depthTraverse(data[key], func, modify); }\n         }\n      }\n      else\n      {\n         func(data);\n      }\n   }\n\n   return data;\n}\n\n/**\n * Private implementation of `getAccessorList`.\n *\n * @param {object}   data - An object to traverse.\n *\n * @returns {string[]} Accessor list.\n * @ignore\n * @private\n */\nfunction _getAccessorList(data)\n{\n   const accessors = [];\n\n   for (const key in data)\n   {\n      if (data.hasOwnProperty(key)) // eslint-disable-line no-prototype-builtins\n      {\n         if (typeof data[key] === 'object')\n         {\n            const childKeys = _getAccessorList(data[key]);\n\n            childKeys.forEach((childKey) =>\n            {\n               accessors.push(Array.isArray(childKey) ? `${key}.${childKey.join('.')}` : `${key}.${childKey}`);\n            });\n         }\n         else\n         {\n            accessors.push(key);\n         }\n      }\n   }\n\n   return accessors;\n}\n\n/**\n * Creates a new error of type `clazz` adding the field `_objectValidateError` set to true.\n *\n * @param {Error}    clazz - Error class to instantiate.\n *\n * @param {string}   message - An error message.\n *\n * @returns {*} Error of the clazz.\n * @ignore\n * @private\n */\nfunction _validateError(clazz, message = void 0)\n{\n   const error = new clazz(message);\n   error._objectValidateError = true;\n   return error;\n}\n","/**\r\n * PluginEvent - Provides the data / event passed to all invoked methods in\r\n * {@link PluginInvokeSupport#invokeSyncEvent}. The `event.data` field is returned to the caller. Before returning\r\n * though additional the following additional metadata is attached:\r\n *\r\n * (number)    `$$plugin_invoke_count` - The count of plugins invoked.\r\n *\r\n * (string[])  `$$plugin_invoke_names` - The names of plugins invoked.\r\n */\r\nexport default class PluginInvokeEvent\r\n{\r\n   /**\r\n    * Initializes PluginEvent.\r\n    *\r\n    * @param {object} copyProps - Event data to copy.\r\n    *\r\n    * @param {object} passthruProps - Event data to pass through.\r\n    */\r\n   constructor(copyProps = {}, passthruProps = {})\r\n   {\r\n      /**\r\n       * Provides the unified event data assigning any pass through data to the copied data supplied. Invoked functions\r\n       * may add to or modify this data.\r\n       *\r\n       * @type {PluginEventData}\r\n       */\r\n      this.data = Object.assign(JSON.parse(JSON.stringify(copyProps)), passthruProps);\r\n\r\n      /**\r\n       * Unique data available in each plugin invoked.\r\n       *\r\n       * @type {EventbusProxy} - The active EventbusProxy for that particular plugin.\r\n       */\r\n      this.eventbus = void 0;\r\n\r\n      /**\r\n       * Unique data available in each plugin invoked.\r\n       *\r\n       * @type {string} - The active plugin name.\r\n       */\r\n      this.pluginName = void 0;\r\n\r\n      /**\r\n       * Unique data available in each plugin invoked.\r\n       *\r\n       * @type {object} - The active plugin options.\r\n       */\r\n      this.pluginOptions = void 0;\r\n   }\r\n}\r\n","import { isIterable }      from '@typhonjs-utils/object';\r\n\r\nimport PluginInvokeEvent   from './PluginInvokeEvent.js';\r\n\r\n/**\r\n * Private implementation to invoke asynchronous events. This allows internal calls in PluginManager for\r\n * `onPluginLoad` and `onPluginUnload` callbacks to bypass optional error checking.\r\n *\r\n * This dispatch method asynchronously passes to and returns from any invoked targets a PluginEvent. Any invoked plugin\r\n * may return a Promise which is awaited upon by `Promise.all` before returning the PluginEvent data via a Promise.\r\n *\r\n * @param {object}                     opts - Options object.\r\n *\r\n * @param {string}                     opts.method - Method name to invoke.\r\n *\r\n * @param {PluginManager}              opts.manager - A plugin manager instance.\r\n *\r\n * @param {object}                     [opts.copyProps] - Properties that are copied.\r\n *\r\n * @param {object}                     [opts.passthruProps] - Properties that are passed through.\r\n *\r\n * @param {string|Iterable<string>}    [opts.plugins] - Specific plugin name or iterable list of plugin names to invoke.\r\n *\r\n * @param {object}                     [opts.options] - Defines options for throwing exceptions. Turned off by default.\r\n *\r\n * @param {boolean}                    [opts.errorCheck=true] - If false optional error checking is disabled.\r\n *\r\n * @returns {Promise<PluginEventData>} The PluginEvent data.\r\n */\r\nexport default async function invokeAsyncEvent({ method, manager, copyProps = {}, passthruProps = {}, plugins = void 0,\r\n options = void 0, errorCheck = true })\r\n{\r\n   if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\r\n   if (typeof passthruProps !== 'object') { throw new TypeError(`'passthruProps' is not an object.`); }\r\n   if (typeof copyProps !== 'object') { throw new TypeError(`'copyProps' is not an object.`); }\r\n\r\n   if (options === void 0) { options = manager.getOptions(); }\r\n   if (plugins === void 0) { plugins = manager.getPluginMapKeys(); }\r\n\r\n   if (typeof plugins !== 'string' && !isIterable(plugins))\r\n   {\r\n      throw new TypeError(`'plugins' is not a string or iterable.`);\r\n   }\r\n\r\n   // Track how many plugins were invoked.\r\n   let pluginInvokeCount = 0;\r\n   const pluginInvokeNames = [];\r\n\r\n   // Track if a plugin method is invoked\r\n   let hasMethod = false;\r\n   let hasPlugin = false;\r\n\r\n   // Create plugin event.\r\n   const ev = new PluginInvokeEvent(copyProps, passthruProps);\r\n\r\n   const results = [];\r\n\r\n   if (typeof plugins === 'string')\r\n   {\r\n      const entry = manager.getPluginEntry(plugins);\r\n\r\n      if (entry !== void 0 && entry.enabled && entry.instance)\r\n      {\r\n         hasPlugin = true;\r\n\r\n         if (typeof entry.instance[method] === 'function')\r\n         {\r\n            ev.eventbus = entry.eventbusProxy;\r\n            ev.pluginName = entry.name;\r\n            ev.pluginOptions = entry.data.plugin.options;\r\n\r\n            const result = entry.instance[method](ev);\r\n\r\n            if (typeof result !== 'undefined' && result !== null) { results.push(result); }\r\n\r\n            hasMethod = true;\r\n            pluginInvokeCount++;\r\n            pluginInvokeNames.push(entry.name);\r\n         }\r\n      }\r\n   }\r\n   else\r\n   {\r\n      for (const name of plugins)\r\n      {\r\n         const entry = manager.getPluginEntry(name);\r\n\r\n         if (entry !== void 0 && entry.enabled && entry.instance)\r\n         {\r\n            hasPlugin = true;\r\n\r\n            if (typeof entry.instance[method] === 'function')\r\n            {\r\n               ev.eventbus = entry.eventbusProxy;\r\n               ev.pluginName = entry.name;\r\n               ev.pluginOptions = entry.data.plugin.options;\r\n\r\n               const result = entry.instance[method](ev);\r\n\r\n               if (typeof result !== 'undefined' && result !== null) { results.push(result); }\r\n\r\n               hasMethod = true;\r\n               pluginInvokeCount++;\r\n               pluginInvokeNames.push(entry.name);\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   if (errorCheck && options.throwNoPlugin && !hasPlugin)\r\n   {\r\n      throw new Error(`PluginManager failed to find any target plugins.`);\r\n   }\r\n\r\n   if (errorCheck && options.throwNoMethod && !hasMethod)\r\n   {\r\n      throw new Error(`PluginManager failed to invoke '${method}'.`);\r\n   }\r\n\r\n   // Add meta data for plugin invoke count.\r\n   ev.data.$$plugin_invoke_count = pluginInvokeCount;\r\n   ev.data.$$plugin_invoke_names = pluginInvokeNames;\r\n\r\n   await Promise.all(results);\r\n\r\n   return ev.data;\r\n}\r\n","const s_REGEX_ESCAPE_RELATIVE = /^([.]{1,2}[\\\\|/])+/g;\r\nconst s_REGEX_ESCAPE_FORWARD = /[\\\\]/g;\r\nconst s_REGEX_STRING_URL = /^(https?|file):/g;\r\n\r\n/**\r\n * Creates an escaped path which is suitable for use in RegExp construction.\r\n *\r\n * Note: This function will throw if a malformed URL string is the target. In AbstractPluginManager this function\r\n * is used after the module has been loaded / is a good target.\r\n *\r\n * @param {string|URL}  target - Target full / relative path or URL to escape.\r\n *\r\n * @returns {string} The escaped target.\r\n */\r\nexport default function escapeTarget(target)\r\n{\r\n   let targetEscaped = target;\r\n\r\n   if (target instanceof URL)\r\n   {\r\n      targetEscaped = target.pathname;\r\n   }\r\n   else if (target.match(s_REGEX_STRING_URL))\r\n   {\r\n      targetEscaped = new URL(target).pathname;\r\n   }\r\n\r\n   targetEscaped = targetEscaped.replace(s_REGEX_ESCAPE_RELATIVE, '');\r\n   targetEscaped = targetEscaped.replace(s_REGEX_ESCAPE_FORWARD, '\\\\\\\\');\r\n\r\n   return targetEscaped;\r\n}\r\n","/**\r\n * Performs validation of a PluginConfig.\r\n *\r\n * @param {PluginConfig}   pluginConfig A PluginConfig to validate.\r\n *\r\n * @returns {boolean} True if the given PluginConfig is valid.\r\n */\r\nexport default function isValidConfig(pluginConfig)\r\n{\r\n   if (typeof pluginConfig !== 'object') { return false; }\r\n\r\n   if (typeof pluginConfig.name !== 'string') { return false; }\r\n\r\n   if (typeof pluginConfig.target !== 'undefined' && typeof pluginConfig.target !== 'string' &&\r\n    !(pluginConfig.target instanceof URL))\r\n   {\r\n      return false;\r\n   }\r\n\r\n   if (typeof pluginConfig.options !== 'undefined' && typeof pluginConfig.options !== 'object') { return false; }\r\n\r\n   return true;\r\n}\r\n","/**\r\n * Resolves a dynamically imported module for PluginManager. This function is passed to `@typhonjs-utils/loader-module`.\r\n *\r\n * @param {object}   module - The imported module.\r\n *\r\n * @returns {*} The export most likely to match a valid plugin.\r\n */\r\nexport default function(module)\r\n{\r\n   // If the module has a named export for `onPluginLoad` then take the module.\r\n   if (typeof module.onPluginLoad === 'function')\r\n   {\r\n      return module;\r\n   }\r\n   // Then potentially resolve any default export / static class.\r\n   else if (module.default)\r\n   {\r\n      return module.default;\r\n   }\r\n   // Finally resolve as just the module.\r\n   else\r\n   {\r\n      return module;\r\n   }\r\n}\r\n","import Eventbus                           from '@typhonjs-plugin/eventbus';\r\nimport { EventbusProxy, EventbusSecure }  from '@typhonjs-plugin/eventbus';\r\nimport ModuleLoader                       from '@typhonjs-utils/loader-module';\r\n\r\nimport PluginEntry                        from './PluginEntry.js';\r\n\r\nimport invokeAsyncEvent                   from './support/invoke/invokeAsyncEvent.js';\r\n\r\nimport escapeTarget                       from './utils/escapeTarget.js';\r\nimport isValidConfig                      from './utils/isValidConfig.js';\r\nimport resolveModule                      from './utils/resolveModule.js';\r\n\r\nimport { deepFreeze, isIterable, isObject }  from '@typhonjs-utils/object';\r\n\r\n/**\r\n * Provides a lightweight plugin manager for Node / NPM & the browser with eventbus integration for plugins in a safe\r\n * and protected manner across NPM modules, local files, and preloaded object instances. This pattern facilitates\r\n * message passing between modules versus direct dependencies / method invocation.\r\n *\r\n * A default eventbus will be created, but you may also pass in an eventbus from `@typhonjs-plugin/eventbus` and the\r\n * plugin manager will register by default under these event categories:\r\n *\r\n * `plugins:async:add` - {@link PluginManager#add}\r\n *\r\n * `plugins:async:add:all` - {@link PluginManager#addAll}\r\n *\r\n * `plugins:async:destroy:manager` - {@link PluginManager#destroy}\r\n *\r\n * `plugins:async:remove` - {@link PluginManager#remove}\r\n *\r\n * `plugins:async:remove:all` - {@link PluginManager#removeAll}\r\n *\r\n * `plugins:get:enabled` - {@link PluginManager#getEnabled}\r\n *\r\n * `plugins:get:options` - {@link PluginManager#getOptions}\r\n *\r\n * `plugins:get:plugin:by:event` - {@link PluginManager#getPluginByEvent}\r\n *\r\n * `plugins:get:plugin:data` - {@link PluginManager#getPluginData}\r\n *\r\n * `plugins:get:plugin:events` - {@link PluginManager#getPluginEvents}\r\n *\r\n * `plugins:get:plugin:names` - {@link PluginManager#getPluginNames}\r\n *\r\n * `plugins:has:plugin` - {@link PluginManager#hasPlugins}\r\n *\r\n * `plugins:is:valid:config` - {@link PluginManager#isValidConfig}\r\n *\r\n * `plugins:set:enabled` - {@link PluginManager#setEnabled}\r\n *\r\n * `plugins:set:options` - {@link PluginManager#setOptions}\r\n *\r\n * Automatically when a plugin is loaded and unloaded respective functions `onPluginLoad` and `onPluginUnload` will\r\n * be attempted to be invoked on the plugin. This is an opportunity for the plugin to receive any associated eventbus\r\n * and wire itself into it. It should be noted that a protected proxy around the eventbus is passed to the plugins\r\n * such that when the plugin is removed automatically all events registered on the eventbus are cleaned up without\r\n * a plugin author needing to do this manually in the `onPluginUnload` callback. This solves any dangling event binding\r\n * issues.\r\n *\r\n * By supporting ES Modules / CommonJS in Node and ES Modules in the browser the plugin manager is by nature\r\n * asynchronous for the core methods of adding / removing plugins and destroying the manager. The lifecycle methods\r\n * `onPluginLoad` and `onPluginUnload` will be awaited on such that if a plugin returns a Promise or is an async method\r\n * then it will complete before execution continues.\r\n *\r\n * It is recommended to interact with the plugin manager eventbus through an eventbus proxy. The\r\n * `createEventbusProxy` method will return a proxy to the default or currently set eventbus.\r\n *\r\n * It should be noted that this module reexports `@typhonjs-plugin/eventbus` which are available as named exports on\r\n * this module:\r\n * import {\r\n *   Eventbus,\r\n *   EventbusProxy,\r\n *   EventbusSecure,\r\n *   eventbus,\r\n *   pluginEventbus,\r\n *   testEventbus\r\n * } from '@typhonjs-plugin/manager';\r\n *\r\n * This reexport is for convenience as it provides one single distribution for Node & browser usage.\r\n *\r\n * If external eventbus functionality is enabled by passing in an eventbus in the constructor of PluginManager it is\r\n * important especially if using an existing process / global level eventbus instance from either this module or\r\n * `@typhonjs-plugin/eventbus` to call {@link PluginManager#destroy} to clean up all plugin eventbus resources and the\r\n * plugin manager event bindings; this is primarily a testing concern when running repeated tests over a reused\r\n * eventbus.\r\n *\r\n * For more information on Eventbus functionality please see:\r\n *\r\n * @see https://www.npmjs.com/package/@typhonjs-plugin/eventbus\r\n *\r\n * The PluginManager instance can be extended through runtime composition by passing in _classes_ that implement\r\n * {@link PluginSupportImpl}. One such implementation is available {@link PluginInvokeSupport} which enables directly\r\n * invoking methods of all or specific plugins. Please see the documentation for PluginInvokeSupport for more details.\r\n *\r\n * Several abbreviated examples follow. Please see the wiki for more details:\r\n * TODO: add wiki link\r\n *\r\n * @example\r\n * import PluginManager from '@typhonjs-plugin/manager';\r\n *\r\n * const pluginManager = new PluginManager();\r\n *\r\n * await pluginManager.add({ name: 'an-npm-plugin-enabled-module' });\r\n * await pluginManager.add({ name: 'my-local-module', target: './myModule.js' });\r\n *\r\n * const eventbus = pluginManager.createEventbusProxy();\r\n *\r\n * // Let's say an-npm-plugin-enabled-module responds to 'cool:event' which returns 'true'.\r\n * // Let's say my-local-module responds to 'hot:event' which returns 'false'.\r\n * // Both of the plugin / modules will have 'onPluginLoaded' invoked with a proxy to the eventbus and any plugin\r\n * // options defined.\r\n *\r\n * // One can then use the eventbus functionality to invoke associated module / plugin methods even retrieving results.\r\n * assert(eventbus.triggerSync('cool:event') === true);\r\n * assert(eventbus.triggerSync('hot:event') === false);\r\n *\r\n */\r\nexport default class PluginManager\r\n{\r\n   /**\r\n    * Stores the associated eventbus.\r\n    *\r\n    * @type {Eventbus}\r\n    * @private\r\n    */\r\n   #eventbus = null;\r\n\r\n   /**\r\n    * Stores any EventbusProxy instances created, so that they may be automatically destroyed.\r\n    *\r\n    * @type {EventbusProxy[]}\r\n    * @private\r\n    */\r\n   #eventbusProxies = [];\r\n\r\n   /**\r\n    * Stores any EventbusSecure instances created, so that they may be automatically destroyed.\r\n    *\r\n    * @type {EventbusSecureObj[]}\r\n    * @private\r\n    */\r\n   #eventbusSecure = [];\r\n\r\n   /**\r\n    * Defines various options for the plugin manager. By default plugins are enabled, no event invoke, and no\r\n    * event set options are enabled; the latter two preventing invoke dispatch methods functioning on the eventbus\r\n    * along with not being able to set the plugin manager options by the eventbus. These must be explicitly turned\r\n    * off.\r\n    *\r\n    * @type {PluginManagerOptions}\r\n    * @private\r\n    */\r\n   #options =\r\n   {\r\n      noEventAdd: false,\r\n      noEventDestroy: true,\r\n      noEventRemoval: false,\r\n      noEventSetEnabled: true,\r\n      noEventSetOptions: true,\r\n      throwNoMethod: false,\r\n      throwNoPlugin: false\r\n   };\r\n\r\n   /**\r\n    * Stores the plugins currently being loaded by plugin name. During the add process this is important to track\r\n    * in cases when PluginManager is being used incorrectly in a non-async / await manner.\r\n    *\r\n    * @type {Set<string>}\r\n    * @private\r\n    */\r\n   #pluginAddSet = new Set();\r\n\r\n   /**\r\n    * Stores the plugins by name with an associated PluginEntry.\r\n    *\r\n    * @type {Map<string, PluginEntry>}\r\n    * @private\r\n    */\r\n   #pluginMap = new Map();\r\n\r\n   /**\r\n    * Provides an array of PluginSupportImpl interfaces to extend the plugin manager through the eventbus API.\r\n    *\r\n    * @type {PluginSupportImpl[]}\r\n    * @private\r\n    */\r\n   #pluginSupport = [];\r\n\r\n   /**\r\n    * Instantiates PluginManager\r\n    *\r\n    * @param {object}   [options] - Provides various configuration options:\r\n    *\r\n    * @param {Eventbus} [options.eventbus] - An instance of '@typhonjs-plugin/eventbus' used as the plugin\r\n    *                                        eventbus. If not provided a default eventbus is created.\r\n    *\r\n    * @param {string}   [options.eventPrepend='plugin'] - A customized name to prepend PluginManager events on the\r\n    *                                                     eventbus.\r\n    *\r\n    * @param {PluginManagerOptions}  [options.manager] - The plugin manager options.\r\n    *\r\n    * @param {PluginSupportImpl|Iterable<PluginSupportImpl>} [options.PluginSupport] - Optional classes to\r\n    *                                        pass in which extends the plugin manager. A default implementation is\r\n    *                                        available: {@link PluginInvokeSupport}\r\n    */\r\n   constructor(options = {})\r\n   {\r\n      if (!isObject(options)) { throw new TypeError(`'options' is not an object.`); }\r\n\r\n      if (options.eventbus !== void 0 && !isObject(options.eventbus))\r\n      {\r\n         throw new TypeError(`'options.eventbus' is not an Eventbus.`);\r\n      }\r\n\r\n      if (options.eventPrepend !== void 0 && typeof options.eventPrepend !== 'string')\r\n      {\r\n         throw new TypeError(`'options.eventPrepend' is not a string.`);\r\n      }\r\n\r\n      if (options.manager !== void 0 && !isObject(options.manager))\r\n      {\r\n         throw new TypeError(`'options.manager' is not an object.`);\r\n      }\r\n\r\n      if (options.PluginSupport !== void 0 && typeof options.PluginSupport !== 'function' &&\r\n       !isIterable(options.PluginSupport))\r\n      {\r\n         throw new TypeError(\r\n          `'options.PluginSupport' must be a constructor function or iterable of such matching PluginSupportImpl.`);\r\n      }\r\n\r\n      // Instantiate any PluginSupport classes\r\n      if (isIterable(options.PluginSupport))\r\n      {\r\n         for (const PluginSupport of options.PluginSupport)\r\n         {\r\n            this.#pluginSupport.push(new PluginSupport(this));\r\n         }\r\n      }\r\n      else if (options.PluginSupport !== void 0)\r\n      {\r\n         this.#pluginSupport.push(new options.PluginSupport(this));\r\n      }\r\n\r\n      this.setOptions(options.manager || {});\r\n\r\n      this.setEventbus({\r\n         eventbus: options.eventbus !== void 0 ? options.eventbus : new Eventbus(),\r\n         eventPrepend: options.eventPrepend\r\n      });\r\n   }\r\n\r\n   /**\r\n    * Adds a plugin by the given configuration parameters. A plugin `name` is always required. If no other options\r\n    * are provided then the `name` doubles as the NPM module / local file to load. The loading first checks for an\r\n    * existing `instance` to use as the plugin. Then the `target` is chosen as the NPM module / local file to load.\r\n    * By passing in `options` this will be stored and accessible to the plugin during all callbacks.\r\n    *\r\n    * @param {PluginConfig}   pluginConfig - Defines the plugin to load.\r\n    *\r\n    * @param {object}         [moduleData] - Optional object hash to associate with plugin.\r\n    *\r\n    * @returns {Promise<PluginData>} The PluginData that represents the plugin added.\r\n    */\r\n   async add(pluginConfig, moduleData)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (typeof pluginConfig !== 'object') { throw new TypeError(`'pluginConfig' is not an object.`); }\r\n\r\n      if (typeof pluginConfig.name !== 'string')\r\n      {\r\n         throw new TypeError(\r\n          `'pluginConfig.name' is not a string for entry:\\n${JSON.stringify(pluginConfig, null, 3)}`);\r\n      }\r\n\r\n      if (pluginConfig.target !== void 0 && typeof pluginConfig.target !== 'string' &&\r\n       !(pluginConfig.target instanceof URL))\r\n      {\r\n         throw new TypeError(\r\n          `'pluginConfig.target' is not a string or URL for entry:\\n${JSON.stringify(pluginConfig, null, 3)}`);\r\n      }\r\n\r\n      if (pluginConfig.options !== void 0 && typeof pluginConfig.options !== 'object')\r\n      {\r\n         throw new TypeError(\r\n          `'pluginConfig.options' is not an object for entry:\\n${JSON.stringify(pluginConfig, null, 3)}`);\r\n      }\r\n\r\n      if (moduleData !== void 0 && typeof moduleData !== 'object')\r\n      {\r\n         throw new TypeError(`'moduleData' is not an object for entry:\\n${JSON.stringify(pluginConfig, null, 3)}`);\r\n      }\r\n\r\n      // If a plugin with the same name already exists post a warning and exit early.\r\n      if (this.#pluginMap.has(pluginConfig.name))\r\n      {\r\n         throw new Error(`A plugin already exists with name: ${pluginConfig.name} for entry:\\n${\r\n          JSON.stringify(pluginConfig, null, 3)}`);\r\n      }\r\n\r\n      // If a plugin with the same name is also being currently loaded post a warning and exit early. This is the case\r\n      // when add is used without await and multiple plugins w/ the same name are being dynamically imported.\r\n      if (this.#pluginAddSet.has(pluginConfig.name))\r\n      {\r\n         throw new Error(`A plugin is already being loaded with name: ${pluginConfig.name} for entry:\\n${\r\n          JSON.stringify(pluginConfig, null, 3)}`);\r\n      }\r\n\r\n      this.#pluginAddSet.add(pluginConfig.name);\r\n\r\n      let instance, target, type;\r\n\r\n      // Use an existing instance of a plugin; a static class is assumed when instance is a function.\r\n      if (typeof pluginConfig.instance === 'object' || typeof pluginConfig.instance === 'function')\r\n      {\r\n         instance = pluginConfig.instance;\r\n\r\n         target = pluginConfig.name;\r\n\r\n         type = 'instance';\r\n      }\r\n      else\r\n      {\r\n         // If a target is defined use it instead of the name.\r\n         target = pluginConfig.target || pluginConfig.name;\r\n\r\n         try\r\n         {\r\n            const result = await ModuleLoader.load({ modulepath: target, resolveModule });\r\n\r\n            // Please note that a plugin or other logger must be setup on the associated eventbus.\r\n            if (this.#eventbus !== null)\r\n            {\r\n               this.#eventbus.trigger('log:debug',\r\n                `@typhonjs-plugin/manager - ${result.isESM ? 'import' : 'require'}: ${result.loadpath}`);\r\n            }\r\n\r\n            instance = result.instance;\r\n            type = result.type;\r\n         }\r\n         catch (err)\r\n         {\r\n            // Remove tracking of given plugin config name.\r\n            this.#pluginAddSet.delete(pluginConfig.name);\r\n\r\n            throw new Error(`@typhonjs-plugin/manager - Could not load target: ${target}\\n\\nPluginConfig:\\n` +\r\n             `${JSON.stringify(pluginConfig, null, 3)}\\n\\n${err}`);\r\n         }\r\n      }\r\n\r\n      // Convert any URL target a string.\r\n      if (target instanceof URL)\r\n      {\r\n         target = target.toString();\r\n      }\r\n\r\n      /**\r\n       * Create an object hash with data describing the plugin, manager, and any extra module data.\r\n       *\r\n       * @type {PluginData}\r\n       */\r\n      const pluginData = JSON.parse(JSON.stringify(\r\n      {\r\n         manager:\r\n         {\r\n            eventPrepend: this._eventPrepend,\r\n            scopedName: `${this._eventPrepend}:${pluginConfig.name}`\r\n         },\r\n\r\n         module: moduleData || {},\r\n\r\n         plugin:\r\n         {\r\n            name: pluginConfig.name,\r\n            target,\r\n            targetEscaped: escapeTarget(target),\r\n            type,\r\n            options: pluginConfig.options || {}\r\n         }\r\n      }));\r\n\r\n      deepFreeze(pluginData, ['manager']);\r\n\r\n      const eventbusProxy = this.#eventbus !== null && this.#eventbus !== void 0 ?\r\n       new EventbusProxy(this.#eventbus) /* c8 ignore next */ : void 0;\r\n\r\n      const entry = new PluginEntry(pluginConfig.name, pluginData, instance, eventbusProxy);\r\n\r\n      this.#pluginMap.set(pluginConfig.name, entry);\r\n      this.#pluginAddSet.delete(pluginConfig.name);\r\n\r\n      // Invokes the private internal async events method which allows skipping of error checking.\r\n      const invokeData = await invokeAsyncEvent({\r\n         method: 'onPluginLoad',\r\n         manager: this,\r\n         plugins: pluginConfig.name,\r\n         errorCheck: false\r\n      });\r\n\r\n      if (typeof invokeData.importmeta === 'object')\r\n      {\r\n         entry.importmeta = invokeData.importmeta;\r\n\r\n         // Until we get a Snowpack HMR spec environment for testing ignore this block.\r\n         /* c8 ignore next 7 */\r\n         if (typeof invokeData.importmeta.hot === 'object' && typeof invokeData.importmeta.hot.accept === 'function')\r\n         {\r\n            invokeData.importmeta.hot.accept(({ module }) =>\r\n            {\r\n               this.reload({ plugin: pluginConfig.name, instance: resolveModule(module) });\r\n            });\r\n         }\r\n      }\r\n\r\n      // Invoke `typhonjs:plugin:manager:plugin:added` allowing external code to react to plugin addition.\r\n      if (this.#eventbus)\r\n      {\r\n         await this.#eventbus.triggerAsync(`typhonjs:plugin:manager:plugin:added`, pluginData);\r\n      }\r\n\r\n      return pluginData;\r\n   }\r\n\r\n   /**\r\n    * Initializes multiple plugins in a single call.\r\n    *\r\n    * @param {Iterable<PluginConfig>}   pluginConfigs - An iterable list of plugin config object hash entries.\r\n    *\r\n    * @param {object}                   [moduleData] - Optional object hash to associate with all plugins.\r\n    *\r\n    * @returns {Promise<PluginData[]>} An array of PluginData objects of all added plugins.\r\n    */\r\n   async addAll(pluginConfigs, moduleData)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (!isIterable(pluginConfigs)) { throw new TypeError(`'pluginConfigs' is not iterable.`); }\r\n\r\n      const pluginsData = [];\r\n\r\n      for (const pluginConfig of pluginConfigs)\r\n      {\r\n         const result = await this.add(pluginConfig, moduleData);\r\n\r\n         if (result) { pluginsData.push(result); }\r\n      }\r\n\r\n      return pluginsData;\r\n   }\r\n\r\n   /**\r\n    * Provides the eventbus callback which may prevent addition if optional `noEventAdd` is enabled. This disables\r\n    * the ability for plugins to be added via events preventing any external code adding plugins in this manner.\r\n    *\r\n    * @param {PluginConfig}   pluginConfig - Defines the plugin to load.\r\n    *\r\n    * @param {object}         [moduleData] - Optional object hash to associate with all plugins.\r\n    *\r\n    * @returns {Promise<PluginData>} The PluginData that represents the plugin added.\r\n    * @private\r\n    */\r\n   async _addEventbus(pluginConfig, moduleData)\r\n   {\r\n      /* c8 ignore next */\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      return !this.#options.noEventAdd ? this.add(pluginConfig, moduleData) : void 0;\r\n   }\r\n\r\n   /**\r\n    * Provides the eventbus callback which may prevent addition if optional `noEventAdd` is enabled. This disables\r\n    * the ability for plugins to be added via events preventing any external code adding plugins in this manner.\r\n    *\r\n    * @param {Iterable<PluginConfig>}  pluginConfigs - An iterable list of plugin config object hash entries.\r\n    *\r\n    * @param {object}                  [moduleData] - Optional object hash to associate with all plugins.\r\n    *\r\n    * @returns {Promise<PluginData[]>} An array of PluginData objects of all added plugins.\r\n    * @private\r\n    */\r\n   async _addAllEventbus(pluginConfigs, moduleData)\r\n   {\r\n      /* c8 ignore next */\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      return !this.#options.noEventAdd ? this.addAll(pluginConfigs, moduleData) : [];\r\n   }\r\n\r\n   /**\r\n    * If an eventbus is assigned to this plugin manager then a new EventbusProxy wrapping this eventbus is returned.\r\n    * It is added to `this.#eventbusProxies` so â€ hat the instances are destroyed when the plugin manager is destroyed.\r\n    *\r\n    * @returns {EventbusProxy} A proxy for the currently set Eventbus.\r\n    */\r\n   createEventbusProxy()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      /* c8 ignore next */\r\n      if (this.#eventbus === null) { throw new ReferenceError('No eventbus assigned to plugin manager.'); }\r\n\r\n      const eventbusProxy = new EventbusProxy(this.#eventbus);\r\n\r\n      // Store proxy to make sure it is destroyed when the plugin manager is destroyed.\r\n      this.#eventbusProxies.push(eventbusProxy);\r\n\r\n      return eventbusProxy;\r\n   }\r\n\r\n   /**\r\n    * If an eventbus is assigned to this plugin manager then a new EventbusSecure wrapping this eventbus is returned.\r\n    * It is added to `this.#eventbusSecure` so â€ hat the instances are destroyed when the plugin manager is destroyed.\r\n    *\r\n    * @param {string}   [name] - Optional name for the EventbusSecure instance.\r\n    *\r\n    * @returns {EventbusSecure} A secure wrapper for the currently set Eventbus.\r\n    */\r\n   createEventbusSecure(name = void 0)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      /* c8 ignore next */\r\n      if (this.#eventbus === null) { throw new ReferenceError('No eventbus assigned to plugin manager.'); }\r\n\r\n      const eventbusSecureObj = EventbusSecure.initialize(this.#eventbus, name);\r\n\r\n      // Store EventbusSecure object to make sure it is destroyed when the plugin manager is destroyed.\r\n      this.#eventbusSecure.push(eventbusSecureObj);\r\n\r\n      return eventbusSecureObj.eventbusSecure;\r\n   }\r\n\r\n   /**\r\n    * Destroys all managed plugins after unloading them.\r\n    *\r\n    * @returns {Promise<DataOutPluginRemoved[]>} A list of plugin names and removal success state.\r\n    */\r\n   async destroy()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      // Remove all plugins; this will invoke onPluginUnload.\r\n      const results = await this.removeAll();\r\n\r\n      // Destroy any EventbusSecure instances created.\r\n      for (const eventbusSecureObj of this.#eventbusSecure)\r\n      {\r\n         eventbusSecureObj.destroy();\r\n      }\r\n\r\n      this.#eventbusSecure = [];\r\n\r\n      // Destroy any EventbusProxy instances created.\r\n      for (const eventbusProxy of this.#eventbusProxies)\r\n      {\r\n         eventbusProxy.destroy();\r\n      }\r\n\r\n      this.#eventbusProxies = [];\r\n\r\n      if (this.#eventbus !== null && this.#eventbus !== void 0)\r\n      {\r\n         this.#eventbus.off(`${this._eventPrepend}:async:add`, this._addEventbus, this);\r\n         this.#eventbus.off(`${this._eventPrepend}:async:add:all`, this._addAllEventbus, this);\r\n         this.#eventbus.off(`${this._eventPrepend}:async:destroy:manager`, this._destroyEventbus, this);\r\n         this.#eventbus.off(`${this._eventPrepend}:async:remove`, this._removeEventbus, this);\r\n         this.#eventbus.off(`${this._eventPrepend}:async:remove:all`, this._removeAllEventbus, this);\r\n         this.#eventbus.off(`${this._eventPrepend}:get:enabled`, this.getEnabled, this);\r\n         this.#eventbus.off(`${this._eventPrepend}:get:plugin:by:event`, this.getPluginByEvent, this);\r\n         this.#eventbus.off(`${this._eventPrepend}:get:plugin:data`, this.getPluginData, this);\r\n         this.#eventbus.off(`${this._eventPrepend}:get:plugin:events`, this.getPluginEvents, this);\r\n         this.#eventbus.off(`${this._eventPrepend}:get:plugin:names`, this.getPluginNames, this);\r\n         this.#eventbus.off(`${this._eventPrepend}:get:options`, this.getOptions, this);\r\n         this.#eventbus.off(`${this._eventPrepend}:has:plugin`, this.hasPlugins, this);\r\n         this.#eventbus.off(`${this._eventPrepend}:is:valid:config`, this.isValidConfig, this);\r\n         this.#eventbus.off(`${this._eventPrepend}:set:enabled`, this._setEnabledEventbus, this);\r\n         this.#eventbus.off(`${this._eventPrepend}:set:options`, this._setOptionsEventbus, this);\r\n      }\r\n\r\n      for (const pluginSupport of this.#pluginSupport)\r\n      {\r\n         await pluginSupport.destroy({ eventbus: this.#eventbus, eventPrepend: this._eventPrepend });\r\n      }\r\n\r\n      this.#pluginSupport = [];\r\n      this.#pluginMap = null;\r\n      this.#eventbus = null;\r\n\r\n      return results;\r\n   }\r\n\r\n   /**\r\n    * Provides the eventbus callback which may prevent plugin manager destruction if optional `noEventDestroy` is\r\n    * enabled. This disables the ability for the plugin manager to be destroyed via events preventing any external\r\n    * code removing plugins in this manner.\r\n    *\r\n    * @private\r\n    * @returns {Promise<DataOutPluginRemoved[]>} A list of plugin names and removal success state.\r\n    */\r\n   async _destroyEventbus()\r\n   {\r\n      /* c8 ignore next */\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      return !this.#options.noEventDestroy ? this.destroy() : [];\r\n   }\r\n\r\n   /**\r\n    * Returns whether this plugin manager has been destroyed.\r\n    *\r\n    * @returns {boolean} Returns whether this plugin manager has been destroyed.\r\n    */\r\n   get isDestroyed()\r\n   {\r\n      return this.#pluginMap === null || this.#pluginMap === void 0;\r\n   }\r\n\r\n   /**\r\n    * Returns the enabled state of a plugin, a list of plugins, or all plugins.\r\n    *\r\n    * @param {object}                  [opts] - Options object. If undefined all plugin enabled state is returned.\r\n    *\r\n    * @param {string|Iterable<string>} [opts.plugins] - Plugin name or iterable list of names to get state.\r\n    *\r\n    * @returns {boolean|DataOutPluginEnabled[]} Enabled state for single plugin or array of results for multiple\r\n    *                                                plugins.\r\n    */\r\n   getEnabled({ plugins = [] } = {})\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (typeof plugins !== 'string' && !isIterable(plugins))\r\n      {\r\n         throw new TypeError(`'plugins' is not a string or iterable.`);\r\n      }\r\n\r\n      // Return a single boolean enabled result for a single plugin if found.\r\n      if (typeof plugins === 'string')\r\n      {\r\n         const entry = this.#pluginMap.get(plugins);\r\n         return entry !== void 0 && entry.enabled;\r\n      }\r\n\r\n      const results = [];\r\n\r\n      let count = 0;\r\n\r\n      for (const plugin of plugins)\r\n      {\r\n         const entry = this.#pluginMap.get(plugin);\r\n         const loaded = entry !== void 0;\r\n         results.push({ plugin, enabled: loaded && entry.enabled, loaded });\r\n         count++;\r\n      }\r\n\r\n      // Iterable plugins had no entries so return all plugin data.\r\n      if (count === 0)\r\n      {\r\n         for (const [plugin, entry] of this.#pluginMap.entries())\r\n         {\r\n            const loaded = entry !== void 0;\r\n            results.push({ plugin, enabled: loaded && entry.enabled, loaded });\r\n         }\r\n      }\r\n\r\n      return results;\r\n   }\r\n\r\n   /**\r\n    * Returns any associated eventbus.\r\n    *\r\n    * @returns {Eventbus} The associated eventbus.\r\n    */\r\n   getEventbus()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      return this.#eventbus;\r\n   }\r\n\r\n   /**\r\n    * Returns a copy of the plugin manager options.\r\n    *\r\n    * @returns {PluginManagerOptions} A copy of the plugin manager options.\r\n    */\r\n   getOptions()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      return JSON.parse(JSON.stringify(this.#options));\r\n   }\r\n\r\n   /**\r\n    * Returns the event binding names registered on any associated plugin EventbusProxy.\r\n    *\r\n    * @param {object}          opts - Options object.\r\n    *\r\n    * @param {string|RegExp}   opts.event - Event name or RegExp to match event names.\r\n    *\r\n    * @returns {string[]|DataOutPluginEvents[]} Event binding names registered from the plugin.\r\n    */\r\n   getPluginByEvent({ event })\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (typeof event !== 'string' && !(event instanceof RegExp))\r\n      {\r\n         throw new TypeError(`'event' is not a string or RegExp.`);\r\n      }\r\n\r\n      const pluginEvents = this.getPluginEvents();\r\n\r\n      const results = [];\r\n\r\n      if (typeof event === 'string')\r\n      {\r\n         for (const entry of pluginEvents)\r\n         {\r\n            if (entry.events.includes(event)) { results.push(entry.plugin); }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const entry of pluginEvents)\r\n         {\r\n            for (const eventEntry of entry.events)\r\n            {\r\n               if (event.test(eventEntry))\r\n               {\r\n                  results.push(entry.plugin);\r\n                  break;\r\n               }\r\n            }\r\n         }\r\n      }\r\n\r\n      return results;\r\n   }\r\n\r\n   /**\r\n    * Gets the plugin data for a plugin, list of plugins, or all plugins.\r\n    *\r\n    * @param {object}                  [opts] - Options object. If undefined all plugin data is returned.\r\n    *\r\n    * @param {string|Iterable<string>} [opts.plugins] - Plugin name or iterable list of names to get plugin data.\r\n    *\r\n    * @returns {PluginData|PluginData[]|undefined} The plugin data for a plugin or list of plugins.\r\n    */\r\n   getPluginData({ plugins = [] } = {})\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (typeof plugins !== 'string' && !isIterable(plugins))\r\n      {\r\n         throw new TypeError(`'plugins' is not a string or iterable.`);\r\n      }\r\n\r\n      // Return a PluginData result for a single plugin if found.\r\n      if (typeof plugins === 'string')\r\n      {\r\n         const entry = this.#pluginMap.get(plugins);\r\n         return entry !== void 0 ? JSON.parse(JSON.stringify(entry.data)) : void 0;\r\n      }\r\n\r\n      const results = [];\r\n\r\n      let count = 0;\r\n\r\n      for (const name of plugins)\r\n      {\r\n         const entry = this.#pluginMap.get(name);\r\n\r\n         if (entry !== void 0)\r\n         {\r\n            results.push(JSON.parse(JSON.stringify(entry.data)));\r\n         }\r\n         count++;\r\n      }\r\n\r\n      // Iterable plugins had no entries so return all plugin data.\r\n      if (count === 0)\r\n      {\r\n         for (const entry of this.#pluginMap.values())\r\n         {\r\n            if (entry !== void 0)\r\n            {\r\n               results.push(JSON.parse(JSON.stringify(entry.data)));\r\n            }\r\n         }\r\n      }\r\n\r\n      return results;\r\n   }\r\n\r\n   /**\r\n    * Gets a PluginEntry instance for the given plugin name. This method is primarily for {@link PluginSupportImpl}\r\n    * classes.\r\n    *\r\n    * @param {string} plugin - The plugin name to get.\r\n    *\r\n    * @returns {void|PluginEntry} The PluginEntry for the given plugin name.\r\n    */\r\n   getPluginEntry(plugin)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      return this.#pluginMap.get(plugin);\r\n   }\r\n\r\n   /**\r\n    * Returns the event binding names registered on any associated plugin EventbusProxy.\r\n    *\r\n    * @param {object}                  [opts] - Options object. If undefined all plugin data is returned.\r\n    *\r\n    * @param {string|Iterable<string>} [opts.plugins] - Plugin name or iterable list of names to get plugin data.\r\n    *\r\n    * @returns {string[]|DataOutPluginEvents[]} Event binding names registered from the plugin.\r\n    */\r\n   getPluginEvents({ plugins = [] } = {})\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (typeof plugins !== 'string' && !isIterable(plugins))\r\n      {\r\n         throw new TypeError(`'plugins' is not a string or iterable.`);\r\n      }\r\n\r\n      // Return a PluginData result for a single plugin if found.\r\n      if (typeof plugins === 'string')\r\n      {\r\n         const entry = this.#pluginMap.get(plugins);\r\n         return entry !== void 0 && entry.eventbusProxy ?\r\n          Array.from(entry.eventbusProxy.proxyKeys()).sort() /* c8 ignore next */ : [];\r\n      }\r\n\r\n      const results = [];\r\n\r\n      let count = 0;\r\n\r\n      for (const plugin of plugins)\r\n      {\r\n         const entry = this.#pluginMap.get(plugin);\r\n\r\n         if (entry !== void 0)\r\n         {\r\n            results.push({\r\n               plugin,\r\n               events: entry.eventbusProxy ?\r\n                Array.from(entry.eventbusProxy.proxyKeys()).sort() /* c8 ignore next */ : []\r\n            });\r\n         }\r\n         count++;\r\n      }\r\n\r\n      // Iterable plugins had no entries so return all plugin data.\r\n      if (count === 0)\r\n      {\r\n         for (const entry of this.#pluginMap.values())\r\n         {\r\n            if (entry !== void 0)\r\n            {\r\n               results.push({\r\n                  plugin: entry.name,\r\n                  events: entry.eventbusProxy ?\r\n                   Array.from(entry.eventbusProxy.proxyKeys()).sort() /* c8 ignore next */ : []\r\n               });\r\n            }\r\n         }\r\n      }\r\n\r\n      return results;\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable of plugin map keys (plugin names). This method is primarily for {@link PluginSupportImpl}\r\n    * classes.\r\n    *\r\n    * @returns {Iterable<string>} An iterable of plugin map keys.\r\n    */\r\n   getPluginMapKeys()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      return this.#pluginMap.keys();\r\n   }\r\n\r\n   /**\r\n    * Returns an iterable of plugin map keys (plugin names). This method is primarily for {@link PluginSupportImpl}\r\n    * classes.\r\n    *\r\n    * @returns {Iterable<PluginEntry>} An iterable of plugin map keys.\r\n    */\r\n   getPluginMapValues()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      return this.#pluginMap.values();\r\n   }\r\n\r\n   /**\r\n    * Returns all plugin names or if enabled is set then return plugins matching the enabled state.\r\n    *\r\n    * @param {object}  [opts] - Options object. If undefined all plugin names are returned regardless of enabled state.\r\n    *\r\n    * @param {boolean} [opts.enabled] - If enabled is a boolean it will return plugins given their enabled state.\r\n    *\r\n    * @returns {string[]} A list of plugin names optionally by enabled state.\r\n    */\r\n   getPluginNames({ enabled = void 0 } = {})\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (enabled !== void 0 && typeof enabled !== 'boolean')\r\n      {\r\n         throw new TypeError(`'enabled' is not a boolean.`);\r\n      }\r\n\r\n      const anyEnabledState = enabled === void 0;\r\n\r\n      const results = [];\r\n\r\n      for (const entry of this.#pluginMap.values())\r\n      {\r\n         if (anyEnabledState || entry.enabled === enabled) { results.push(entry.name); }\r\n      }\r\n\r\n      return results.sort();\r\n   }\r\n\r\n   /**\r\n    * Returns true if there is a plugin loaded with the given plugin name(s). If no options are provided then\r\n    * the result will be if any plugins are loaded.\r\n    *\r\n    * @param {object}                  [opts] - Options object. If undefined returns whether there are any plugins.\r\n    *\r\n    * @param {string|Iterable<string>} [opts.plugins] - Plugin name or iterable list of names to check existence.\r\n    *\r\n    * @returns {boolean} True if given plugin(s) exist.\r\n    */\r\n   hasPlugins({ plugins = [] } = {})\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (typeof plugins !== 'string' && !isIterable(plugins))\r\n      {\r\n         throw new TypeError(`'plugins' is not a string or iterable.`);\r\n      }\r\n\r\n      // Return whether a single plugin exists.\r\n      if (typeof plugins === 'string')\r\n      {\r\n         return this.#pluginMap.has(plugins);\r\n      }\r\n\r\n      let count = 0;\r\n\r\n      // Return whether all plugins specified exist.\r\n      for (const name of plugins)\r\n      {\r\n         if (!this.#pluginMap.has(name)) { return false; }\r\n\r\n         count++;\r\n      }\r\n\r\n      // Iterable plugins had no entries so simply check size of the map.\r\n      if (count === 0)\r\n      {\r\n         return this.#pluginMap.size !== 0;\r\n      }\r\n\r\n      return true;\r\n   }\r\n\r\n   /**\r\n    * Performs validation of a PluginConfig.\r\n    *\r\n    * @param {PluginConfig}   pluginConfig - A PluginConfig to validate.\r\n    *\r\n    * @returns {boolean} True if the given PluginConfig is valid.\r\n    */\r\n   isValidConfig(pluginConfig)\r\n   {\r\n      return isValidConfig(pluginConfig);\r\n   }\r\n\r\n   /**\r\n    * Unloads / reloads the plugin invoking `onPluginUnload` / then `onPluginReload`\r\n    *\r\n    * @param {object}   opts - Options object.\r\n    *\r\n    * @param {string}   opts.plugin - Plugin name to reload.\r\n    *\r\n    * @param {object}   [opts.instance] - Optional instance to replace.\r\n    *\r\n    * @param {boolean}  [opts.silent] - Does not trigger any reload notification on the eventbus.\r\n    *\r\n    * @returns {Promise<boolean>} Result of reload attempt.\r\n    */\r\n   async reload({ plugin, instance = void 0, silent = false })\r\n   {\r\n      if (typeof plugin !== 'string') { throw new TypeError(`'plugin' is not a string.`); }\r\n      if (instance !== void 0 && typeof instance !== 'object') { throw new TypeError(`'instance' is not an object.`); }\r\n      if (typeof silent !== 'boolean') { throw new TypeError(`'silent' is not a boolean.`); }\r\n\r\n      const entry = this.#pluginMap.get(plugin);\r\n\r\n      if (entry === void 0) { return false; }\r\n\r\n      // Store any state to load into new plugin instance.\r\n      let state = void 0;\r\n\r\n      let error = void 0;\r\n\r\n      try\r\n      {\r\n         // Invokes the private internal async events method which allows skipping of error checking.\r\n         const unloadData = await invokeAsyncEvent({\r\n            method: 'onPluginUnload',\r\n            manager: this,\r\n            plugins: plugin,\r\n            errorCheck: false\r\n         });\r\n\r\n         state = unloadData.state;\r\n      }\r\n      catch (err)\r\n      {\r\n         error = err;\r\n      }\r\n\r\n      // Automatically clean up most resources.\r\n      entry.reset();\r\n\r\n      if (entry.eventbusProxy instanceof EventbusProxy) { entry.eventbusProxy.off(); }\r\n\r\n      if (typeof instance === 'object')\r\n      {\r\n         entry.instance = instance;\r\n      }\r\n\r\n      // Invokes the private internal async events method which allows skipping of error checking.\r\n      const invokeData = await invokeAsyncEvent({\r\n         method: 'onPluginLoad',\r\n         manager: this,\r\n         plugins: plugin,\r\n         passthruProps: { state },\r\n         errorCheck: false\r\n      });\r\n\r\n      // Invoke `typhonjs:plugin:manager:plugin:reloaded` allowing external code to react to plugin reload.\r\n      try\r\n      {\r\n         if (this.#eventbus && !silent)\r\n         {\r\n            await this.#eventbus.triggerAsync(`typhonjs:plugin:manager:plugin:reloaded`,\r\n             JSON.parse(JSON.stringify(entry.data)));\r\n         }\r\n      }\r\n      catch (err)\r\n      {\r\n         // Only track this error if no previous error exists from onPluginUnload invocation.\r\n         if (error === void 0) { error = err; }\r\n      }\r\n\r\n      if (typeof invokeData.importmeta === 'object')\r\n      {\r\n         entry.importmeta = invokeData.importmeta;\r\n\r\n         // Until we get a Snowpack HMR spec environment for testing ignore this block.\r\n         /* c8 ignore next 7 */\r\n         if (typeof invokeData.importmeta.hot === 'object' && typeof invokeData.importmeta.hot.accept === 'function')\r\n         {\r\n            invokeData.importmeta.hot.accept(({ module }) =>\r\n            {\r\n               this.reload({ plugin, instance: resolveModule(module) });\r\n            });\r\n         }\r\n      }\r\n\r\n      // Throw any error raised first from any onPluginUnload invocation then the\r\n      // `typhonjs:plugin:manager:plugin:reloaded` event.\r\n      if (error) { throw error; }\r\n\r\n      return true;\r\n  }\r\n\r\n   /**\r\n    * Removes a plugin by name or all names in an iterable list unloading them and clearing any event bindings\r\n    * automatically.\r\n    *\r\n    * @param {object}                  opts - Options object.\r\n    *\r\n    * @param {string|Iterable<string>} opts.plugins - Plugin name or iterable list of names to remove.\r\n    *\r\n    * @returns {Promise<DataOutPluginRemoved[]>} A list of plugin names and removal success state.\r\n    */\r\n   async remove({ plugins })\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (typeof plugins !== 'string' && !isIterable(plugins))\r\n      {\r\n         throw new TypeError(`'plugins' is not a string or iterable.`);\r\n      }\r\n\r\n      const removeEntry = async (entry) =>\r\n      {\r\n         const errors = [];\r\n\r\n         const pluginName = entry.name;\r\n\r\n         try\r\n         {\r\n            // Invokes the private internal async events method which allows skipping of error checking.\r\n            await invokeAsyncEvent({ method: 'onPluginUnload', manager: this, plugins: pluginName, errorCheck: false });\r\n         }\r\n         catch (err)\r\n         {\r\n            errors.push(err);\r\n         }\r\n\r\n         entry.reset();\r\n\r\n         if (entry.eventbusProxy instanceof EventbusProxy) { entry.eventbusProxy.destroy(); }\r\n\r\n         this.#pluginMap.delete(pluginName);\r\n\r\n         // Invoke `typhonjs:plugin:manager:plugin:removed` allowing external code to react to plugin removed.\r\n         try\r\n         {\r\n            if (this.#eventbus)\r\n            {\r\n               await this.#eventbus.triggerAsync(`typhonjs:plugin:manager:plugin:removed`,\r\n                JSON.parse(JSON.stringify(entry.data)));\r\n            }\r\n         }\r\n         catch (err)\r\n         {\r\n            errors.push(err);\r\n         }\r\n\r\n         return { plugin: pluginName, success: errors.length === 0, errors };\r\n      };\r\n\r\n      const results = [];\r\n\r\n      // Return a single boolean enabled result for a single plugin if found.\r\n      if (typeof plugins === 'string')\r\n      {\r\n         const entry = this.#pluginMap.get(plugins);\r\n\r\n         if (entry !== void 0)\r\n         {\r\n            results.push(await removeEntry(entry));\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const name of plugins)\r\n         {\r\n            const entry = this.#pluginMap.get(name);\r\n\r\n            if (entry !== void 0)\r\n            {\r\n               results.push(await removeEntry(entry));\r\n            }\r\n         }\r\n      }\r\n\r\n      return results;\r\n   }\r\n\r\n   /**\r\n    * Removes all plugins after unloading them and clearing any event bindings automatically.\r\n    *\r\n    * @returns {Promise.<DataOutPluginRemoved[]>} A list of plugin names and removal success state.\r\n    */\r\n   async removeAll()\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      return this.remove({ plugins: Array.from(this.#pluginMap.keys()) });\r\n   }\r\n\r\n   /**\r\n    * Provides the eventbus callback which may prevent removal if optional `noEventRemoval` is enabled. This disables\r\n    * the ability for plugins to be removed via events preventing any external code removing plugins in this manner.\r\n    *\r\n    * @param {object}                  opts - Options object\r\n    *\r\n    * @param {string|Iterable<string>} opts.plugins - Plugin name or iterable list of names to remove.\r\n    *\r\n    * @returns {Promise<DataOutPluginRemoved>} A list of plugin names and removal success state.\r\n    * @private\r\n    */\r\n   async _removeEventbus(opts)\r\n   {\r\n      /* c8 ignore next */\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      return !this.#options.noEventRemoval ? this.remove(opts) : [];\r\n   }\r\n\r\n   /**\r\n    * Provides the eventbus callback which may prevent removal if optional `noEventRemoval` is enabled. This disables\r\n    * the ability for plugins to be removed via events preventing any external code removing plugins in this manner.\r\n    *\r\n    * @returns {Promise.<DataOutPluginRemoved[]>} A list of plugin names and removal success state.\r\n    * @private\r\n    */\r\n   async _removeAllEventbus()\r\n   {\r\n      /* c8 ignore next */\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      return !this.#options.noEventRemoval ? this.removeAll() : [];\r\n   }\r\n\r\n   /**\r\n    * Sets the enabled state of a plugin, a list of plugins, or all plugins.\r\n    *\r\n    * @param {object}            opts - Options object.\r\n    *\r\n    * @param {boolean}           opts.enabled - The enabled state.\r\n    *\r\n    * @param {string|Iterable<string>} [opts.plugins] - Plugin name or iterable list of names to set state.\r\n    */\r\n   setEnabled({ enabled, plugins = [] })\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (typeof plugins !== 'string' && !isIterable(plugins))\r\n      {\r\n         throw new TypeError(`'plugins' is not a string or iterable.`);\r\n      }\r\n\r\n      if (typeof enabled !== 'boolean') { throw new TypeError(`'enabled' is not a boolean.`); }\r\n\r\n      const setEntryEnabled = (entry) =>\r\n      {\r\n         if (entry !== void 0)\r\n         {\r\n            entry.enabled = enabled;\r\n\r\n            // Invoke `typhonjs:plugin:manager:plugin:enabled` allowing external code to react to plugin enabled state.\r\n            if (this.#eventbus)\r\n            {\r\n               this.#eventbus.trigger(`typhonjs:plugin:manager:plugin:enabled`, Object.assign({\r\n                  enabled\r\n               }, JSON.parse(JSON.stringify(entry.data))));\r\n            }\r\n         }\r\n      };\r\n\r\n      // Set enabled state for a single plugin if found.\r\n      if (typeof plugins === 'string')\r\n      {\r\n         setEntryEnabled(this.#pluginMap.get(plugins));\r\n      }\r\n\r\n      let count = 0;\r\n\r\n      // First attempt to iterate through plugins.\r\n      for (const name of plugins)\r\n      {\r\n         setEntryEnabled(this.#pluginMap.get(name));\r\n         count++;\r\n      }\r\n\r\n      // If plugins is empty then set all plugins enabled state.\r\n      if (count === 0)\r\n      {\r\n         for (const entry of this.#pluginMap.values())\r\n         {\r\n            setEntryEnabled(entry);\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Provides the eventbus callback which may prevent setEnabled if optional `noEventSetEnabled` is true. This\r\n    * disables the ability for setting plugin enabled state via events preventing any external code from setting state.\r\n    *\r\n    * @param {object}   opts - Options object.\r\n    *\r\n    * @private\r\n    */\r\n   _setEnabledEventbus(opts)\r\n   {\r\n      /* c8 ignore next */\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (!this.#options.noEventSetEnabled) { this.setEnabled(opts); }\r\n   }\r\n\r\n   /**\r\n    * Sets the eventbus associated with this plugin manager. If any previous eventbus was associated all plugin manager\r\n    * events will be removed then added to the new eventbus. If there are any existing plugins being managed their\r\n    * events will be removed from the old eventbus and then `onPluginLoad` will be called with the new eventbus.\r\n    *\r\n    * @param {object}     opts - An options object.\r\n    *\r\n    * @param {Eventbus}   opts.eventbus - The new eventbus to associate.\r\n    *\r\n    * @param {string}     [opts.eventPrepend='plugins'] - An optional string to prepend to all of the event\r\n    *                                                     binding targets.\r\n    */\r\n   async setEventbus({ eventbus, eventPrepend = 'plugins' })\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (!isObject(eventbus)) { throw new TypeError(`'eventbus' is not an Eventbus.`); }\r\n      if (typeof eventPrepend !== 'string') { throw new TypeError(`'eventPrepend' is not a string.`); }\r\n\r\n      // Early escape if the eventbus is the same as the current eventbus.\r\n      if (eventbus === this.#eventbus) { return; }\r\n\r\n      const oldPrepend = this._eventPrepend;\r\n\r\n      /**\r\n       * Stores the prepend string for eventbus registration.\r\n       *\r\n       * @type {string}\r\n       * @private\r\n       */\r\n      this._eventPrepend = eventPrepend;\r\n\r\n      // Unload and reload any existing plugins from the old eventbus to the target eventbus.\r\n      if (this.#pluginMap.size > 0)\r\n      {\r\n         // Invokes the private internal async events method which allows skipping of error checking.\r\n         await invokeAsyncEvent({ method: 'onPluginUnload', manager: this, errorCheck: false });\r\n\r\n         for (const entry of this.#pluginMap.values())\r\n         {\r\n            try\r\n            {\r\n               // Automatically remove any potential reference to a stored event proxy instance.\r\n               delete entry.instance._eventbus;\r\n            }\r\n            /* c8 ignore next */\r\n            catch (err) { /* nop */ }\r\n\r\n            entry.data.manager.eventPrepend = eventPrepend;\r\n            entry.data.manager.scopedName = `${eventPrepend}:${entry.name}`;\r\n\r\n            if (entry.eventbusProxy instanceof EventbusProxy) { entry.eventbusProxy.destroy(); }\r\n\r\n            entry.eventbusProxy = new EventbusProxy(eventbus);\r\n\r\n            // Invokes the private internal async events method which allows skipping of error checking.\r\n            if (entry.enabled)\r\n            {\r\n               await invokeAsyncEvent({\r\n                  method: 'onPluginLoad',\r\n                  manager: this,\r\n                  plugins: entry.name,\r\n                  errorCheck: false\r\n               });\r\n            }\r\n         }\r\n      }\r\n\r\n      if (this.#eventbus !== null)\r\n      {\r\n         this.#eventbus.off(`${oldPrepend}:async:add`, this._addEventbus, this);\r\n         this.#eventbus.off(`${oldPrepend}:async:add:all`, this._addAllEventbus, this);\r\n         this.#eventbus.off(`${oldPrepend}:async:destroy:manager`, this._destroyEventbus, this);\r\n         this.#eventbus.off(`${oldPrepend}:async:remove`, this._removeEventbus, this);\r\n         this.#eventbus.off(`${oldPrepend}:async:remove:all`, this._removeAllEventbus, this);\r\n         this.#eventbus.off(`${oldPrepend}:get:enabled`, this.getEnabled, this);\r\n         this.#eventbus.off(`${oldPrepend}:get:options`, this.getOptions, this);\r\n         this.#eventbus.off(`${oldPrepend}:get:plugin:by:event`, this.getPluginByEvent, this);\r\n         this.#eventbus.off(`${oldPrepend}:get:plugin:data`, this.getPluginData, this);\r\n         this.#eventbus.off(`${oldPrepend}:get:plugin:events`, this.getPluginEvents, this);\r\n         this.#eventbus.off(`${oldPrepend}:get:plugin:names`, this.getPluginNames, this);\r\n         this.#eventbus.off(`${oldPrepend}:has:plugin`, this.hasPlugins, this);\r\n         this.#eventbus.off(`${oldPrepend}:is:valid:config`, this.isValidConfig, this);\r\n         this.#eventbus.off(`${oldPrepend}:set:enabled`, this._setEnabledEventbus, this);\r\n         this.#eventbus.off(`${oldPrepend}:set:options`, this._setOptionsEventbus, this);\r\n      }\r\n\r\n      eventbus.on(`${eventPrepend}:async:add`, this._addEventbus, this, { guard: true });\r\n      eventbus.on(`${eventPrepend}:async:add:all`, this._addAllEventbus, this, { guard: true });\r\n      eventbus.on(`${eventPrepend}:async:destroy:manager`, this._destroyEventbus, this, { guard: true });\r\n      eventbus.on(`${eventPrepend}:async:remove`, this._removeEventbus, this, { guard: true });\r\n      eventbus.on(`${eventPrepend}:async:remove:all`, this._removeAllEventbus, this, { guard: true });\r\n      eventbus.on(`${eventPrepend}:get:enabled`, this.getEnabled, this, { guard: true });\r\n      eventbus.on(`${eventPrepend}:get:options`, this.getOptions, this, { guard: true });\r\n      eventbus.on(`${eventPrepend}:get:plugin:by:event`, this.getPluginByEvent, this, { guard: true });\r\n      eventbus.on(`${eventPrepend}:get:plugin:data`, this.getPluginData, this, { guard: true });\r\n      eventbus.on(`${eventPrepend}:get:plugin:events`, this.getPluginEvents, this, { guard: true });\r\n      eventbus.on(`${eventPrepend}:get:plugin:names`, this.getPluginNames, this, { guard: true });\r\n      eventbus.on(`${eventPrepend}:has:plugin`, this.hasPlugins, this, { guard: true });\r\n      eventbus.on(`${eventPrepend}:is:valid:config`, this.isValidConfig, this, { guard: true });\r\n      eventbus.on(`${eventPrepend}:set:enabled`, this._setEnabledEventbus, this, { guard: true });\r\n      eventbus.on(`${eventPrepend}:set:options`, this._setOptionsEventbus, this, { guard: true });\r\n\r\n      for (const pluginSupport of this.#pluginSupport)\r\n      {\r\n         pluginSupport.setEventbus({\r\n            oldEventbus: this.#eventbus,\r\n            newEventbus: eventbus,\r\n            oldPrepend,\r\n            newPrepend: eventPrepend\r\n         });\r\n      }\r\n\r\n      // Set the new eventbus for any EventbusSecure instances created.\r\n      for (const eventbusSecureObj of this.#eventbusSecure)\r\n      {\r\n         eventbusSecureObj.setEventbus(eventbus);\r\n      }\r\n\r\n      this.#eventbus = eventbus;\r\n   }\r\n\r\n   /**\r\n    * Set optional parameters.\r\n    *\r\n    * @param {PluginManagerOptions} options - Defines optional parameters to set.\r\n    */\r\n   setOptions(options)\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (!isObject(options)) { throw new TypeError(`'options' is not an object.`); }\r\n\r\n      if (typeof options.noEventAdd === 'boolean') { this.#options.noEventAdd = options.noEventAdd; }\r\n\r\n      if (typeof options.noEventDestroy === 'boolean') { this.#options.noEventDestroy = options.noEventDestroy; }\r\n\r\n      if (typeof options.noEventRemoval === 'boolean') { this.#options.noEventRemoval = options.noEventRemoval; }\r\n\r\n      if (typeof options.noEventSetEnabled === 'boolean')\r\n      {\r\n         this.#options.noEventSetEnabled = options.noEventSetEnabled;\r\n      }\r\n\r\n      if (typeof options.noEventSetOptions === 'boolean')\r\n      {\r\n         this.#options.noEventSetOptions = options.noEventSetOptions;\r\n      }\r\n\r\n      if (typeof options.throwNoMethod === 'boolean') { this.#options.throwNoMethod = options.throwNoMethod; }\r\n\r\n      if (typeof options.throwNoPlugin === 'boolean') { this.#options.throwNoPlugin = options.throwNoPlugin; }\r\n\r\n      for (const pluginSupport of this.#pluginSupport)\r\n      {\r\n         pluginSupport.setOptions(options);\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Provides the eventbus callback which may prevent plugin manager options being set if optional `noEventSetOptions`\r\n    * is enabled. This disables the ability for the plugin manager options to be set via events preventing any external\r\n    * code modifying options.\r\n    *\r\n    * @param {PluginManagerOptions} options - Defines optional parameters to set.\r\n    *\r\n    * @private\r\n    */\r\n   _setOptionsEventbus(options)\r\n   {\r\n      /* c8 ignore next */\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (!this.#options.noEventSetOptions) { this.setOptions(options); }\r\n   }\r\n}\r\n","import { isIterable }   from \"@typhonjs-utils/object\";\r\n\r\nimport invokeAsyncEvent from './invokeAsyncEvent.js';\r\nimport invokeSyncEvent  from './invokeSyncEvent.js';\r\n\r\n/**\r\n * PluginInvokeSupport adds direct method invocation support to PluginManager via the eventbus and alternately through\r\n * a wrapped instance of PluginManager depending on the use case.\r\n *\r\n * There are two types of invocation methods the first spreads an array of arguments to the invoked method. The second\r\n * constructs a {@link PluginInvokeEvent} to pass to the method with a single parameter.\r\n *\r\n * TODO: more info and wiki link\r\n *\r\n * When added to a PluginManager through constructor initialization the following events are registered on the plugin\r\n * manager eventbus:\r\n *\r\n * `plugins:async:invoke` - {@link PluginInvokeSupport#invokeAsync}\r\n *\r\n * `plugins:async:invoke:event` - {@link PluginInvokeSupport#invokeAsyncEvent}\r\n *\r\n * `plugins:get:method:names` - {@link PluginInvokeSupport#getMethodNames}\r\n *\r\n * `plugins:has:method` - {@link PluginInvokeSupport#hasMethod}\r\n *\r\n * `plugins:invoke` - {@link PluginInvokeSupport#invoke}\r\n *\r\n * `plugins:sync:invoke` - {@link PluginInvokeSupport#invokeSync}\r\n *\r\n * `plugins:sync:invoke:event` - {@link PluginInvokeSupport#invokeSyncEvent}\r\n *\r\n * @example\r\n * // One can also indirectly invoke any method of the plugin.\r\n * // Any plugin with a method named `aCoolMethod` is invoked.\r\n * eventbus.triggerSync('plugins:invoke:sync:event', { method: 'aCoolMethod' });\r\n *\r\n * // A specific invocation just for the 'an-npm-plugin-enabled-module'\r\n * eventbus.triggerSync('plugins:invoke:sync:event', {\r\n *    method: 'aCoolMethod',\r\n *    plugins: 'an-npm-plugin-enabled-module'\r\n * });\r\n *\r\n * // There are two other properties `copyProps` and `passthruProps` which can be set with object data to _copy_ or\r\n * // _pass through_ to the invoked method.\r\n *\r\n * @implements {PluginSupportImpl}\r\n */\r\nexport default class PluginInvokeSupport\r\n{\r\n   /**\r\n    * @type {PluginManager}\r\n    */\r\n   #pluginManager = null;\r\n\r\n   /**\r\n    * Create PluginInvokeSupport\r\n    *\r\n    * @param {PluginManager} pluginManager - The plugin manager to associate.\r\n    */\r\n   constructor(pluginManager)\r\n   {\r\n      this.#pluginManager = pluginManager;\r\n   }\r\n\r\n   /**\r\n    * Returns whether the associated plugin manager has been destroyed.\r\n    *\r\n    * @returns {boolean} Returns whether the plugin manager has been destroyed.\r\n    */\r\n   get isDestroyed()\r\n   {\r\n      return this.#pluginManager === null || this.#pluginManager.isDestroyed;\r\n   }\r\n\r\n   /**\r\n    * Returns the associated plugin manager options.\r\n    *\r\n    * @returns {PluginManagerOptions} The associated plugin manager options.\r\n    */\r\n   get options()\r\n   {\r\n      /* c8 ignore next 1 */\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      return this.#pluginManager.getOptions();\r\n   }\r\n\r\n   /**\r\n    * Gets the associated plugin manager.\r\n    *\r\n    * @returns {PluginManager} The associated plugin manager\r\n    */\r\n   get pluginManager()\r\n   {\r\n      /* c8 ignore next 1 */\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      return this.#pluginManager;\r\n   }\r\n\r\n   /**\r\n    * Destroys all managed plugins after unloading them.\r\n    *\r\n    * @param {object}     opts - An options object.\r\n    *\r\n    * @param {Eventbus}   opts.eventbus - The eventbus to disassociate.\r\n    *\r\n    * @param {string}     opts.eventPrepend - The current event prepend.\r\n    */\r\n   async destroy({ eventbus, eventPrepend })\r\n   {\r\n      if (eventbus !== null && eventbus !== void 0)\r\n      {\r\n         eventbus.off(`${eventPrepend}:async:invoke`, this.invokeAsync, this);\r\n         eventbus.off(`${eventPrepend}:async:invoke:event`, this.invokeAsyncEvent, this);\r\n         eventbus.off(`${eventPrepend}:get:method:names`, this.getMethodNames, this);\r\n         eventbus.off(`${eventPrepend}:has:method`, this.hasMethod, this);\r\n         eventbus.off(`${eventPrepend}:invoke`, this.invoke, this);\r\n         eventbus.off(`${eventPrepend}:sync:invoke`, this.invokeSync, this);\r\n         eventbus.off(`${eventPrepend}:sync:invoke:event`, this.invokeSyncEvent, this);\r\n      }\r\n\r\n      this.#pluginManager = null;\r\n   }\r\n\r\n   /**\r\n    * Returns method names for a specific plugin, list of plugins, or all plugins. The enabled state can be specified\r\n    * along with sorting methods by plugin name.\r\n    *\r\n    * @param {object}                  [opts] - Options object. If undefined all plugin data is returned.\r\n    *\r\n    * @param {boolean}                 [opts.enabled] - If enabled is a boolean it will return plugin methods names\r\n    *                                                   given the respective enabled state.\r\n    *\r\n    * @param {string|Iterable<string>} [opts.plugins] - Plugin name or iterable list of names.\r\n    *\r\n    * @returns {string[]} A list of method names\r\n    */\r\n   getMethodNames({ enabled = void 0, plugins = [] } = {})\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (enabled !== void 0 && typeof enabled !== 'boolean')\r\n      {\r\n         throw new TypeError(`'enabled' is not a boolean.`);\r\n      }\r\n\r\n      if (typeof plugins !== 'string' && !isIterable(plugins))\r\n      {\r\n         throw new TypeError(`'plugins' is not a string or iterable.`);\r\n      }\r\n\r\n      // Create an array from a single plugin name.\r\n      if (typeof plugins === 'string')\r\n      {\r\n         plugins = [plugins];\r\n      }\r\n\r\n      const anyEnabledState = enabled === void 0;\r\n\r\n      const results = {};\r\n\r\n      let count = 0;\r\n\r\n      for (const name of plugins)\r\n      {\r\n         const entry = this.pluginManager.getPluginEntry(name);\r\n\r\n         if (entry !== void 0 && entry.instance && (anyEnabledState || entry.enabled === enabled))\r\n         {\r\n            for (const name of s_GET_ALL_PROPERTY_NAMES(entry.instance))\r\n            {\r\n               // Skip any names that are not a function or are the constructor.\r\n               if (typeof entry.instance[name] === 'function' && name !== 'constructor') { results[name] = true; }\r\n            }\r\n         }\r\n\r\n         count++;\r\n      }\r\n\r\n      // Iterable plugins had no entries so return all plugin data.\r\n      if (count === 0)\r\n      {\r\n         for (const entry of this.pluginManager.getPluginMapValues())\r\n         {\r\n            if (entry.instance && (anyEnabledState || entry.enabled === enabled))\r\n            {\r\n               for (const name of s_GET_ALL_PROPERTY_NAMES(entry.instance))\r\n               {\r\n                  // Skip any names that are not a function or are the constructor.\r\n                  if (typeof entry.instance[name] === 'function' && name !== 'constructor') { results[name] = true; }\r\n               }\r\n            }\r\n         }\r\n      }\r\n\r\n      return Object.keys(results).sort();\r\n   }\r\n\r\n   /**\r\n    * Checks if the provided method name exists across all plugins or specific plugins if defined.\r\n    *\r\n    * @param {object}                  opts - Options object.\r\n    *\r\n    * @param {string}                  opts.method - Method name to test.\r\n    *\r\n    * @param {string|Iterable<string>} [opts.plugins] - Plugin name or iterable list of names to check for method. If\r\n    *                                                   undefined all plugins must contain the method.\r\n    *\r\n    * @returns {boolean} - True method is found.\r\n    */\r\n   hasMethod({ method, plugins = [] })\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (typeof method !== 'string')\r\n      {\r\n         throw new TypeError(`'method' is not a string.`);\r\n      }\r\n\r\n      if (typeof plugins !== 'string' && !isIterable(plugins))\r\n      {\r\n         throw new TypeError(`'plugins' is not a string or iterable.`);\r\n      }\r\n\r\n      // Return a single boolean enabled result for a single plugin if found.\r\n      if (typeof plugins === 'string')\r\n      {\r\n         const entry = this.pluginManager.getPluginEntry(plugins);\r\n         return entry !== void 0 && typeof entry.instance[method] === 'function';\r\n      }\r\n\r\n      let count = 0;\r\n\r\n      for (const name of plugins)\r\n      {\r\n         const entry = this.pluginManager.getPluginEntry(name);\r\n\r\n         if (entry !== void 0 && typeof entry.instance[method] !== 'function') { return false; }\r\n\r\n         count++;\r\n      }\r\n\r\n      // Iterable plugins had no entries so check all plugin data.\r\n      if (count === 0)\r\n      {\r\n         for (const entry of this.pluginManager.getPluginMapValues())\r\n         {\r\n            if (typeof entry.instance[method] !== 'function') { return false; }\r\n         }\r\n      }\r\n\r\n      return true;\r\n   }\r\n\r\n   /**\r\n    * This dispatch method simply invokes any plugin targets for the given method name.\r\n    *\r\n    * @param {object}   opts - Options object.\r\n    *\r\n    * @param {string}   opts.method - Method name to invoke.\r\n    *\r\n    * @param {*[]}      [opts.args] - Method arguments. This array will be spread as multiple arguments.\r\n    *\r\n    * @param {string|Iterable<string>} [opts.plugins] - Specific plugin name or iterable list of plugin names to invoke.\r\n    */\r\n   invoke({ method, args = void 0, plugins = void 0 })\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\r\n\r\n      if (args !== void 0 && !Array.isArray(args)) { throw new TypeError(`'args' is not an array.`); }\r\n\r\n      if (plugins === void 0) { plugins = this.pluginManager.getPluginMapKeys(); }\r\n\r\n      if (typeof plugins !== 'string' && !isIterable(plugins))\r\n      {\r\n         throw new TypeError(`'plugins' is not a string or iterable.`);\r\n      }\r\n\r\n      // Track if a plugin method is invoked.\r\n      let hasMethod = false;\r\n      let hasPlugin = false;\r\n\r\n      const isArgsArray = Array.isArray(args);\r\n\r\n      if (typeof plugins === 'string')\r\n      {\r\n         const entry = this.pluginManager.getPluginEntry(plugins);\r\n\r\n         if (entry !== void 0 && entry.enabled && entry.instance)\r\n         {\r\n            hasPlugin = true;\r\n\r\n            if (typeof entry.instance[method] === 'function')\r\n            {\r\n               isArgsArray ? entry.instance[method](...args) : entry.instance[method]();\r\n\r\n               hasMethod = true;\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const name of plugins)\r\n         {\r\n            const entry = this.pluginManager.getPluginEntry(name);\r\n\r\n            if (entry !== void 0 && entry.enabled && entry.instance)\r\n            {\r\n               hasPlugin = true;\r\n\r\n               if (typeof entry.instance[method] === 'function')\r\n               {\r\n                  isArgsArray ? entry.instance[method](...args) : entry.instance[method]();\r\n\r\n                  hasMethod = true;\r\n               }\r\n            }\r\n         }\r\n      }\r\n\r\n      if (this.options.throwNoPlugin && !hasPlugin)\r\n      {\r\n         throw new Error(`PluginManager failed to find any target plugins.`);\r\n      }\r\n\r\n      if (this.options.throwNoMethod && !hasMethod)\r\n      {\r\n         throw new Error(`PluginManager failed to invoke '${method}'.`);\r\n      }\r\n   }\r\n\r\n   /**\r\n    * This dispatch method is asynchronous and adds any returned results to an array which is resolved via Promise.all\r\n    * Any target invoked may return a Promise or any result.\r\n    *\r\n    * @param {object}   opts - Options object.\r\n    *\r\n    * @param {string}   opts.method - Method name to invoke.\r\n    *\r\n    * @param {*[]}      [opts.args] - Method arguments. This array will be spread as multiple arguments.\r\n    *\r\n    * @param {string|Iterable<string>} [opts.plugins] - Specific plugin name or iterable list of plugin names to invoke.\r\n    *\r\n    * @returns {Promise<*|*[]>} A single result or array of results.\r\n    */\r\n   async invokeAsync({ method, args = void 0, plugins = void 0 })\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\r\n\r\n      if (args !== void 0 && !Array.isArray(args)) { throw new TypeError(`'args' is not an array.`); }\r\n\r\n      if (plugins === void 0) { plugins = this.pluginManager.getPluginMapKeys(); }\r\n\r\n      if (typeof plugins !== 'string' && !isIterable(plugins))\r\n      {\r\n         throw new TypeError(`'plugins' is not a string or iterable.`);\r\n      }\r\n\r\n      // Track if a plugin method is invoked.\r\n      let hasMethod = false;\r\n      let hasPlugin = false;\r\n\r\n      // Capture results.\r\n      let result = void 0;\r\n      const results = [];\r\n\r\n      const isArgsArray = Array.isArray(args);\r\n\r\n      if (typeof plugins === 'string')\r\n      {\r\n         const plugin = this.pluginManager.getPluginEntry(plugins);\r\n\r\n         if (plugin !== void 0 && plugin.enabled && plugin.instance)\r\n         {\r\n            hasPlugin = true;\r\n\r\n            if (typeof plugin.instance[method] === 'function')\r\n            {\r\n               result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method]();\r\n\r\n               // If we received a valid result push it to the results.\r\n               if (result !== void 0) { results.push(result); }\r\n\r\n               hasMethod = true;\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const name of plugins)\r\n         {\r\n            const plugin = this.pluginManager.getPluginEntry(name);\r\n\r\n            if (plugin !== void 0 && plugin.enabled && plugin.instance)\r\n            {\r\n               hasPlugin = true;\r\n\r\n               if (typeof plugin.instance[method] === 'function')\r\n               {\r\n                  result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method]();\r\n\r\n                  // If we received a valid result push it to the results.\r\n                  if (result !== void 0) { results.push(result); }\r\n\r\n                  hasMethod = true;\r\n               }\r\n            }\r\n         }\r\n      }\r\n\r\n      if (this.options.throwNoPlugin && !hasPlugin)\r\n      {\r\n         throw new Error(`PluginManager failed to find any target plugins.`);\r\n      }\r\n\r\n      if (this.options.throwNoMethod && !hasMethod)\r\n      {\r\n          throw new Error(`PluginManager failed to invoke '${method}'.`);\r\n      }\r\n\r\n      // If there are multiple results then use Promise.all otherwise Promise.resolve.\r\n      return results.length > 1 ? Promise.all(results).then((values) =>\r\n      {\r\n         const filtered = values.filter((entry) => entry !== void 0);\r\n         switch (filtered.length)\r\n         {\r\n            case 0: return void 0;\r\n            case 1: return filtered[0];\r\n            default: return filtered;\r\n         }\r\n      }) : result;\r\n   }\r\n\r\n   /**\r\n    * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\r\n    *\r\n    * @param {object}   opts - Options object.\r\n    *\r\n    * @param {string}   opts.method - Method name to invoke.\r\n    *\r\n    * @param {object}   [opts.copyProps] - Properties that are copied.\r\n    *\r\n    * @param {object}   [opts.passthruProps] - Properties that are passed through.\r\n    *\r\n    * @param {string|Iterable<string>} [opts.plugins] - Specific plugin name or iterable list of plugin names to invoke.\r\n    *\r\n    * @returns {Promise<PluginEventData>} The PluginEvent data.\r\n    */\r\n   async invokeAsyncEvent({ method, copyProps = {}, passthruProps = {}, plugins = void 0 })\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      // Invokes the private internal async events method.\r\n      return invokeAsyncEvent({ method, manager: this.pluginManager, copyProps, passthruProps, plugins });\r\n   }\r\n\r\n   /**\r\n    * This dispatch method synchronously passes back a single value or an array with all results returned by any\r\n    * invoked targets.\r\n    *\r\n    * @param {object}   opts - Options object.\r\n    *\r\n    * @param {string}   opts.method - Method name to invoke.\r\n    *\r\n    * @param {*[]}      [opts.args] - Method arguments. This array will be spread as multiple arguments.\r\n    *\r\n    * @param {string|Iterable<string>} [opts.plugins] - Specific plugin name or iterable list of plugin names to invoke.\r\n    *\r\n    * @returns {*|*[]} A single result or array of results.\r\n    */\r\n   invokeSync({ method, args = void 0, plugins = void 0 })\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\r\n\r\n      if (args !== void 0 && !Array.isArray(args)) { throw new TypeError(`'args' is not an array.`); }\r\n\r\n      if (plugins === void 0) { plugins = this.pluginManager.getPluginMapKeys(); }\r\n\r\n      if (typeof plugins !== 'string' && !isIterable(plugins))\r\n      {\r\n         throw new TypeError(`'plugins' is not a string or iterable.`);\r\n      }\r\n\r\n      // Track if a plugin method is invoked.\r\n      let hasMethod = false;\r\n      let hasPlugin = false;\r\n\r\n      // Capture results.\r\n      let result = void 0;\r\n      const results = [];\r\n\r\n      const isArgsArray = Array.isArray(args);\r\n\r\n      if (typeof plugins === 'string')\r\n      {\r\n         const plugin = this.pluginManager.getPluginEntry(plugins);\r\n\r\n         if (plugin !== void 0 && plugin.enabled && plugin.instance)\r\n         {\r\n            hasPlugin = true;\r\n\r\n            if (typeof plugin.instance[method] === 'function')\r\n            {\r\n               result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method]();\r\n\r\n               // If we received a valid result push it to the results.\r\n               if (result !== void 0) { results.push(result); }\r\n\r\n               hasMethod = true;\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         for (const name of plugins)\r\n         {\r\n            const plugin = this.pluginManager.getPluginEntry(name);\r\n\r\n            if (plugin !== void 0 && plugin.enabled && plugin.instance)\r\n            {\r\n               hasPlugin = true;\r\n\r\n               if (typeof plugin.instance[method] === 'function')\r\n               {\r\n                  result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method]();\r\n\r\n                  // If we received a valid result push it to the results.\r\n                  if (result !== void 0) { results.push(result); }\r\n\r\n                  hasMethod = true;\r\n               }\r\n            }\r\n         }\r\n      }\r\n\r\n      if (this.options.throwNoPlugin && !hasPlugin)\r\n      {\r\n         throw new Error(`PluginManager failed to find any target plugins.`);\r\n      }\r\n\r\n      if (this.options.throwNoMethod && !hasMethod)\r\n      {\r\n         throw new Error(`PluginManager failed to invoke '${method}'.`);\r\n      }\r\n\r\n      // Return the results array if there are more than one or just a single result.\r\n      return results.length > 1 ? results : result;\r\n   }\r\n\r\n   /**\r\n    * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\r\n    *\r\n    * @param {object}            opts - Options object.\r\n    *\r\n    * @param {string}            opts.method - Method name to invoke.\r\n    *\r\n    * @param {object}            [opts.copyProps] - Properties that are copied.\r\n    *\r\n    * @param {object}            [opts.passthruProps] - Properties that are passed through.\r\n    *\r\n    * @param {string|Iterable<string>} [opts.plugins] - Specific plugin name or iterable list of plugin names to invoke.\r\n    *\r\n    * @returns {PluginEventData} The PluginEvent data.\r\n    */\r\n   invokeSyncEvent({ method, copyProps = {}, passthruProps = {}, plugins = void 0 })\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      // Invokes the private internal sync events method.\r\n      return invokeSyncEvent({ method, manager: this.pluginManager, copyProps, passthruProps, plugins });\r\n   }\r\n\r\n   /**\r\n    * Sets the eventbus associated with this plugin manager. If any previous eventbus was associated all plugin manager\r\n    * events will be removed then added to the new eventbus. If there are any existing plugins being managed their\r\n    * events will be removed from the old eventbus and then `onPluginLoad` will be called with the new eventbus.\r\n    *\r\n    * @param {object}     opts - An options object.\r\n    *\r\n    * @param {Eventbus}   opts.oldEventbus - The old eventbus to disassociate.\r\n    *\r\n    * @param {Eventbus}   opts.newEventbus - The new eventbus to associate.\r\n    *\r\n    * @param {string}     opts.oldPrepend - The old event prepend.\r\n    *\r\n    * @param {string}     opts.newPrepend - The new event prepend.\r\n    */\r\n   setEventbus({ oldEventbus, newEventbus, oldPrepend, newPrepend })\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n\r\n      if (oldEventbus !== null && oldEventbus !== void 0)\r\n      {\r\n         oldEventbus.off(`${oldPrepend}:async:invoke`, this.invokeAsync, this);\r\n         oldEventbus.off(`${oldPrepend}:async:invoke:event`, this.invokeAsyncEvent, this);\r\n         oldEventbus.off(`${oldPrepend}:get:method:names`, this.getMethodNames, this);\r\n         oldEventbus.off(`${oldPrepend}:has:method`, this.hasMethod, this);\r\n         oldEventbus.off(`${oldPrepend}:invoke`, this.invoke, this);\r\n         oldEventbus.off(`${oldPrepend}:sync:invoke`, this.invokeSync, this);\r\n         oldEventbus.off(`${oldPrepend}:sync:invoke:event`, this.invokeSyncEvent, this);\r\n      }\r\n\r\n      if (newEventbus !== null && newEventbus !== void 0)\r\n      {\r\n         newEventbus.on(`${newPrepend}:async:invoke`, this.invokeAsync, this, { guard: true });\r\n         newEventbus.on(`${newPrepend}:async:invoke:event`, this.invokeAsyncEvent, this, { guard: true });\r\n         newEventbus.on(`${newPrepend}:get:method:names`, this.getMethodNames, this, { guard: true });\r\n         newEventbus.on(`${newPrepend}:has:method`, this.hasMethod, this, { guard: true });\r\n         newEventbus.on(`${newPrepend}:invoke`, this.invoke, this, { guard: true });\r\n         newEventbus.on(`${newPrepend}:sync:invoke`, this.invokeSync, this, { guard: true });\r\n         newEventbus.on(`${newPrepend}:sync:invoke:event`, this.invokeSyncEvent, this, { guard: true });\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Set optional parameters.\r\n    *\r\n    * @param {PluginManagerOptions} options Defines optional parameters to set.\r\n    */\r\n   setOptions(options)  // eslint-disable-line no-unused-vars\r\n   {\r\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\r\n   }\r\n}\r\n\r\n// Module Private ----------------------------------------------------------------------------------------------------\r\n\r\n/**\r\n * Walks an objects inheritance tree collecting property names stopping before `Object` is reached.\r\n *\r\n * @param {object}   obj - object to walks.\r\n *\r\n * @returns {string[]} A list of property names.\r\n * @ignore\r\n */\r\nconst s_GET_ALL_PROPERTY_NAMES = (obj) =>\r\n{\r\n   const props = [];\r\n\r\n   do\r\n   {\r\n      Object.getOwnPropertyNames(obj).forEach((prop) => { if (props.indexOf(prop) === -1) { props.push(prop); } });\r\n      obj = Object.getPrototypeOf(obj);\r\n   } while (obj !== void 0 && obj !== null && !(obj === Object.prototype));\r\n\r\n   return props;\r\n};\r\n","import { isIterable }      from '@typhonjs-utils/object';\r\n\r\nimport PluginInvokeEvent   from './PluginInvokeEvent.js';\r\n\r\n/**\r\n * Private implementation to invoke synchronous events. This allows internal calls in PluginManager for\r\n * `onPluginLoad` and `onPluginUnload` callbacks to bypass optional error checking.\r\n *\r\n * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\r\n *\r\n * @param {object}                     opts - Options object.\r\n *\r\n * @param {string}                     opts.method - Method name to invoke.\r\n *\r\n * @param {PluginManager}              opts.manager - A plugin manager instance.\r\n *\r\n * @param {object}                     [opts.copyProps] - Properties that are copied.\r\n *\r\n * @param {object}                     [opts.passthruProps] - Properties that are passed through.\r\n *\r\n * @param {string|Iterable<string>}    [opts.plugins] - Specific plugin name or iterable list of plugin names to invoke.\r\n *\r\n * @param {object}                     [opts.options] - Defines options for throwing exceptions. Turned off by default.\r\n *\r\n * @param {boolean}                    [opts.errorCheck=true] - If false optional error checking is disabled.\r\n *\r\n * @returns {PluginEventData} The PluginEvent data.\r\n */\r\nexport default function invokeSyncEvent({ method, manager, copyProps = {}, passthruProps = {}, plugins = void 0,\r\n options = void 0, errorCheck = true })\r\n{\r\n   if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\r\n   if (typeof passthruProps !== 'object') { throw new TypeError(`'passthruProps' is not an object.`); }\r\n   if (typeof copyProps !== 'object') { throw new TypeError(`'copyProps' is not an object.`); }\r\n\r\n   if (options === void 0) { options = manager.getOptions(); }\r\n   if (plugins === void 0) { plugins = manager.getPluginMapKeys(); }\r\n\r\n   if (typeof plugins !== 'string' && !isIterable(plugins))\r\n   {\r\n      throw new TypeError(`'plugins' is not a string or iterable.`);\r\n   }\r\n\r\n   // Track how many plugins were invoked.\r\n   let pluginInvokeCount = 0;\r\n   const pluginInvokeNames = [];\r\n\r\n   // Track if a plugin method is invoked\r\n   let hasMethod = false;\r\n   let hasPlugin = false;\r\n\r\n   // Create plugin event.\r\n   const ev = new PluginInvokeEvent(copyProps, passthruProps);\r\n\r\n   if (typeof plugins === 'string')\r\n   {\r\n      const entry = manager.getPluginEntry(plugins);\r\n\r\n      if (entry !== void 0 && entry.enabled && entry.instance)\r\n      {\r\n         hasPlugin = true;\r\n\r\n         if (typeof entry.instance[method] === 'function')\r\n         {\r\n            ev.eventbus = entry.eventbusProxy;\r\n            ev.pluginName = entry.name;\r\n            ev.pluginOptions = entry.data.plugin.options;\r\n\r\n            entry.instance[method](ev);\r\n\r\n            hasMethod = true;\r\n            pluginInvokeCount++;\r\n            pluginInvokeNames.push(entry.name);\r\n         }\r\n      }\r\n   }\r\n   else\r\n   {\r\n      for (const name of plugins)\r\n      {\r\n         const entry = manager.getPluginEntry(name);\r\n\r\n         if (entry !== void 0 && entry.enabled && entry.instance)\r\n         {\r\n            hasPlugin = true;\r\n\r\n            if (typeof entry.instance[method] === 'function')\r\n            {\r\n               ev.eventbus = entry.eventbusProxy;\r\n               ev.pluginName = entry.name;\r\n               ev.pluginOptions = entry.data.plugin.options;\r\n\r\n               entry.instance[method](ev);\r\n\r\n               hasMethod = true;\r\n               pluginInvokeCount++;\r\n               pluginInvokeNames.push(entry.name);\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   if (errorCheck && options.throwNoPlugin && !hasPlugin)\r\n   {\r\n      throw new Error(`PluginManager failed to find any target plugins.`);\r\n   }\r\n\r\n   if (errorCheck && options.throwNoMethod && !hasMethod)\r\n   {\r\n      throw new Error(`PluginManager failed to invoke '${method}'.`);\r\n   }\r\n\r\n   // Add meta data for plugin invoke count.\r\n   ev.data.$$plugin_invoke_count = pluginInvokeCount;\r\n   ev.data.$$plugin_invoke_names = pluginInvokeNames;\r\n\r\n   return ev.data;\r\n}\r\n"],"names":["eventSplitter","eventsAPI","iteratee","events","name","callback","opts","names","i","context","objectKeys","length","test","split","getErrorName","eventbus","getOptions","output","handlers","Array","isArray","handler","options","guard","type","object","Object","keys","beforeMap","map","after","count","beforeWrapper","s_BEFORE","apply","this","arguments","_callback","before","result","args","Eventbus","constructor","TypeError","_listeners","_listenId","_listeningTo","Number","isInteger","data","isGuarded","console","warn","Utils","JSON","stringify","off","bind","on","regex","RegExp","event","_classPrivateFieldGet","parse","getType","s_GET_TYPE","guarded","s_IS_GUARDED","listenTo","obj","s_TRY_CATCH_IS_GUARDED","id","s_UNIQUE_ID","listeningTo","listening","_listening","Listening","error","s_TRY_CATCH_ON","interop","listenToBefore","stopListening","listenToOnce","s_OFF_API","listeners","s_ON_API","ctx","once","ids","trigger","s_RESULTS_TARGET_API","s_TRIGGER_API","s_TRIGGER_EVENTS","s_TRIGGER_ASYNC_EVENTS","Promise","all","then","results","allResults","pResult","concat","push","triggerDefer","setTimeout","triggerSync","s_TRIGGER_SYNC_EVENTS","listener","cleanup","incrementCount","value","remaining","j","iterateeTarget","resultsType","newArray","objEvents","allEvents","slice","ev","a1","a2","a3","l","call","async","values","filtered","filter","entry","err","idCounter","prefix","EventbusProxy","seal","isDestroyed","ReferenceError","createProxy","destroy","entries","eventCount","callbackCount","keysWithOptions","triggerAsync","EventbusSecure","eventbusSecure","setEventbus","pluginEventbus","testEventbus","s_URL_REGEX","PluginEntry","instance","eventbusProxy","enabled","importmeta","reset","_eventbus","from","proxyEntries","deepFreeze","skipFreezeKeys","_deepFreeze","isIterable","Symbol","iterator","isObject","cntr","key","hasOwnProperty","includes","freeze","PluginInvokeEvent","copyProps","passthruProps","assign","pluginName","pluginOptions","invokeAsyncEvent","method","manager","plugins","errorCheck","getPluginMapKeys","pluginInvokeCount","pluginInvokeNames","hasMethod","hasPlugin","getPluginEntry","plugin","throwNoPlugin","Error","throwNoMethod","$$plugin_invoke_count","$$plugin_invoke_names","s_REGEX_ESCAPE_RELATIVE","s_REGEX_ESCAPE_FORWARD","s_REGEX_STRING_URL","escapeTarget","target","targetEscaped","URL","pathname","match","replace","isValidConfig","pluginConfig","module","onPluginLoad","default","PluginManager","noEventAdd","noEventDestroy","noEventRemoval","noEventSetEnabled","noEventSetOptions","Set","Map","eventPrepend","PluginSupport","setOptions","moduleData","has","add","modulepath","resolveModule","import","loadpath","toString","filepath","isESM","load","delete","pluginData","_eventPrepend","scopedName","set","invokeData","hot","accept","reload","pluginConfigs","pluginsData","addAll","createEventbusProxy","createEventbusSecure","eventbusSecureObj","initialize","removeAll","_addEventbus","_addAllEventbus","_destroyEventbus","_removeEventbus","_removeAllEventbus","getEnabled","getPluginByEvent","getPluginData","getPluginEvents","getPluginNames","hasPlugins","_setEnabledEventbus","_setOptionsEventbus","pluginSupport","get","loaded","getEventbus","pluginEvents","eventEntry","proxyKeys","sort","getPluginMapValues","anyEnabledState","size","silent","state","removeEntry","errors","_this","success","remove","setEnabled","setEntryEnabled","oldPrepend","oldEventbus","newEventbus","newPrepend","PluginInvokeSupport","pluginManager","invokeAsync","getMethodNames","invoke","invokeSync","invokeSyncEvent","s_GET_ALL_PROPERTY_NAMES","isArgsArray","props","getOwnPropertyNames","forEach","prop","indexOf","getPrototypeOf","prototype"],"mappings":"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"}