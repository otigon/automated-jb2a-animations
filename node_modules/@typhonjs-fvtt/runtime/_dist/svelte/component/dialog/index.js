import { SvelteComponent, init, safe_not_equal, flush, element, space, attr, insert, append, detach, add_render_callback, select_option, listen, text, set_data, destroy_each, prevent_default, noop, component_subscribe, set_input_value, run_all, update_keyed_each, destroy_block, toggle_class, select_value, binding_callbacks } from 'svelte/internal';
import { getContext } from 'svelte';
import { localize, selectOptions, radioBoxes } from '@typhonjs-fvtt/runtime/svelte/helper';
import { TJSDocument } from '@typhonjs-fvtt/runtime/svelte/store';

/* src\component\dialog\document\TJSDocumentCreate.svelte generated by Svelte v3.46.0 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[19] = list[i];
	return child_ctx;
}

// (80:3) {#if hasTypes}
function create_if_block_1(ctx) {
	let div1;
	let label_1;
	let t1;
	let div0;
	let select;
	let raw_value = selectOptions(/*types*/ ctx[6], { selected: /*type*/ ctx[5] }) + "";

	return {
		c() {
			div1 = element("div");
			label_1 = element("label");
			label_1.textContent = `${localize('Type')}`;
			t1 = space();
			div0 = element("div");
			select = element("select");
			attr(select, "name", "type");
			attr(div0, "class", "form-fields");
			attr(div1, "class", "form-group");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, label_1);
			append(div1, t1);
			append(div1, div0);
			append(div0, select);
			select.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty & /*types, type*/ 96 && raw_value !== (raw_value = selectOptions(/*types*/ ctx[6], { selected: /*type*/ ctx[5] }) + "")) select.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

// (91:3) {#if folders.length >= 1}
function create_if_block(ctx) {
	let div1;
	let label_1;
	let t1;
	let div0;
	let select;
	let option;
	let mounted;
	let dispose;
	let each_value = /*folders*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	return {
		c() {
			div1 = element("div");
			label_1 = element("label");
			label_1.textContent = `${localize('DOCUMENT.Folder')}`;
			t1 = space();
			div0 = element("div");
			select = element("select");
			option = element("option");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			option.__value = "";
			option.value = option.__value;
			attr(select, "name", "folder");
			if (/*folderSelect*/ ctx[2] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[14].call(select));
			attr(div0, "class", "form-fields");
			attr(div1, "class", "form-group");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, label_1);
			append(div1, t1);
			append(div1, div0);
			append(div0, select);
			append(select, option);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*folderSelect*/ ctx[2]);

			if (!mounted) {
				dispose = listen(select, "change", /*select_change_handler*/ ctx[14]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*folders*/ 8) {
				each_value = /*folders*/ ctx[3];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*folderSelect, folders*/ 12) {
				select_option(select, /*folderSelect*/ ctx[2]);
			}
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};
}

// (97:15) {#each folders as folder}
function create_each_block$2(ctx) {
	let option;
	let t_value = /*folder*/ ctx[19].name + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*folder*/ ctx[19].id;
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty & /*folders*/ 8 && t_value !== (t_value = /*folder*/ ctx[19].name + "")) set_data(t, t_value);

			if (dirty & /*folders*/ 8 && option_value_value !== (option_value_value = /*folder*/ ctx[19].id)) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

function create_fragment$8(ctx) {
	let form_1;
	let div1;
	let label_1;
	let t1;
	let div0;
	let input;
	let t2;
	let t3;
	let mounted;
	let dispose;
	let if_block0 = /*hasTypes*/ ctx[4] && create_if_block_1(ctx);
	let if_block1 = /*folders*/ ctx[3].length >= 1 && create_if_block(ctx);

	return {
		c() {
			form_1 = element("form");
			div1 = element("div");
			label_1 = element("label");
			label_1.textContent = `${localize('Name')}`;
			t1 = space();
			div0 = element("div");
			input = element("input");
			t2 = space();
			if (if_block0) if_block0.c();
			t3 = space();
			if (if_block1) if_block1.c();
			attr(input, "type", "text");
			attr(input, "name", "name");
			attr(input, "placeholder", /*name*/ ctx[1]);
			input.required = true;
			attr(div0, "class", "form-fields");
			attr(div1, "class", "form-group");
			attr(form_1, "id", "document-create");
			attr(form_1, "autocomplete", "off");
		},
		m(target, anchor) {
			insert(target, form_1, anchor);
			append(form_1, div1);
			append(div1, label_1);
			append(div1, t1);
			append(div1, div0);
			append(div0, input);
			append(form_1, t2);
			if (if_block0) if_block0.m(form_1, null);
			append(form_1, t3);
			if (if_block1) if_block1.m(form_1, null);
			/*form_1_binding*/ ctx[15](form_1);

			if (!mounted) {
				dispose = listen(form_1, "submit", prevent_default(/*saveData*/ ctx[7]));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*name*/ 2) {
				attr(input, "placeholder", /*name*/ ctx[1]);
			}

			if (/*hasTypes*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(form_1, t3);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*folders*/ ctx[3].length >= 1) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(form_1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(form_1);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			/*form_1_binding*/ ctx[15](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	let { documentCls = void 0 } = $$props;
	let { data = {} } = $$props;
	let { parent = null } = $$props;
	let { pack = null } = $$props;
	let { renderSheet = true } = $$props;
	const { application } = getContext('external');
	let form;
	let name, folderSelect, folders, hasTypes, type, types;

	if (!Object.prototype.isPrototypeOf.call(foundry.abstract.Document, documentCls)) {
		throw new TypeError(`TJSCreateDocument error: 'documentCls' is not a Document.`);
	}

	// Collect data
	const documentName = documentCls.metadata.name;

	const label = localize(documentCls.metadata.label);
	folderSelect = data.folder || '';

	folders = parent
	? []
	: game.folders.filter(f => f.data.type === documentName && f.displayed);

	types = game.system.documentTypes[documentName];
	hasTypes = types.length > 1;
	name = data.name || localize('DOCUMENT.New', { type: label });
	type = data.type || types[0];

	types = types.reduce(
		(obj, t) => {
			const typeLabel = CONFIG[documentName]?.typeLabels?.[t] ?? t;
			obj[t] = game.i18n.has(typeLabel) ? localize(typeLabel) : t;
			return obj;
		},
		{}
	);

	function requestSubmit() {
		form.requestSubmit();
	}

	/**
 * Creates a new document from the form data.
 *
 * @returns {Promise<void>}
 */
	async function saveData(event) {
		const fd = new FormDataExtended(event.target);
		foundry.utils.mergeObject(data, fd.toObject(), { inplace: true });

		if (!data.folder) {
			delete data['folder'];
		}

		if (types.length === 1) {
			$$invalidate(8, data.type = types[0], data);
		}

		const document = await documentCls.create(data, { parent, pack, renderSheet });
		application.options.resolve?.(document);
		application.close();
	}

	function select_change_handler() {
		folderSelect = select_value(this);
		$$invalidate(2, folderSelect);
		$$invalidate(3, folders);
	}

	function form_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			form = $$value;
			$$invalidate(0, form);
		});
	}

	$$self.$$set = $$props => {
		if ('documentCls' in $$props) $$invalidate(9, documentCls = $$props.documentCls);
		if ('data' in $$props) $$invalidate(8, data = $$props.data);
		if ('parent' in $$props) $$invalidate(10, parent = $$props.parent);
		if ('pack' in $$props) $$invalidate(11, pack = $$props.pack);
		if ('renderSheet' in $$props) $$invalidate(12, renderSheet = $$props.renderSheet);
	};

	return [
		form,
		name,
		folderSelect,
		folders,
		hasTypes,
		type,
		types,
		saveData,
		data,
		documentCls,
		parent,
		pack,
		renderSheet,
		requestSubmit,
		select_change_handler,
		form_1_binding
	];
}

class TJSDocumentCreate extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8, create_fragment$8, safe_not_equal, {
			documentCls: 9,
			data: 8,
			parent: 10,
			pack: 11,
			renderSheet: 12,
			requestSubmit: 13
		});
	}

	get documentCls() {
		return this.$$.ctx[9];
	}

	set documentCls(documentCls) {
		this.$$set({ documentCls });
		flush();
	}

	get data() {
		return this.$$.ctx[8];
	}

	set data(data) {
		this.$$set({ data });
		flush();
	}

	get parent() {
		return this.$$.ctx[10];
	}

	set parent(parent) {
		this.$$set({ parent });
		flush();
	}

	get pack() {
		return this.$$.ctx[11];
	}

	set pack(pack) {
		this.$$set({ pack });
		flush();
	}

	get renderSheet() {
		return this.$$.ctx[12];
	}

	set renderSheet(renderSheet) {
		this.$$set({ renderSheet });
		flush();
	}

	get requestSubmit() {
		return this.$$.ctx[13];
	}
}

/* src\component\dialog\document\TJSDocumentDelete.svelte generated by Svelte v3.46.0 */

function create_fragment$7(ctx) {
	let h4;
	let t1;
	let p;
	let t2_value = localize('SIDEBAR.DeleteWarning', { type: /*type*/ ctx[0] }) + "";
	let t2;

	return {
		c() {
			h4 = element("h4");
			h4.textContent = `${localize('AreYouSure')}`;
			t1 = space();
			p = element("p");
			t2 = text(t2_value);
		},
		m(target, anchor) {
			insert(target, h4, anchor);
			insert(target, t1, anchor);
			insert(target, p, anchor);
			append(p, t2);
		},
		p(ctx, [dirty]) {
			if (dirty & /*type*/ 1 && t2_value !== (t2_value = localize('SIDEBAR.DeleteWarning', { type: /*type*/ ctx[0] }) + "")) set_data(t2, t2_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(h4);
			if (detaching) detach(t1);
			if (detaching) detach(p);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let $doc;
	let { document = void 0 } = $$props;
	let { context = {} } = $$props;
	const { application } = getContext('external');

	if (!(document instanceof foundry.abstract.Document)) {
		throw new TypeError(`TJSDocumentDelete error: 'document' is not an instance of Document.`);
	}

	const doc = new TJSDocument(document,
	{
			delete: application.close.bind(application)
		});

	component_subscribe($$self, doc, value => $$invalidate(5, $doc = value));
	(document?.id) ? document.name : '';
	let type = localize(document.constructor.metadata.label);

	async function deleteDocument() {
		// Remove the delete Document function callback as we are intentionally deleting below.
		doc.setOptions({ delete: void 0 });

		const returnDoc = await document.delete(context);
		application.options.resolve?.(returnDoc);
	}

	$$self.$$set = $$props => {
		if ('document' in $$props) $$invalidate(2, document = $$props.document);
		if ('context' in $$props) $$invalidate(3, context = $$props.context);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*context*/ 8) {
			if (typeof context !== 'object') {
				throw new TypeError(`TJSDocumentDelete error: 'context' is not an object.`);
			}
		}

		if ($$self.$$.dirty & /*$doc, document, type*/ 37) {
			if ($doc !== document) {
				if (!(document instanceof foundry.abstract.Document)) {
					throw new TypeError(`TJSDocumentDelete error: 'document' is not an instance of Document.`);
				}

				doc.set(document);
				(document?.id) ? document.name : '';
				$$invalidate(0, type = localize(document.constructor.metadata.label));
				application.data.set('title', `${localize('DOCUMENT.Delete', { type })}: ${document.name}`);
			}
		}
	};

	return [type, doc, document, context, deleteDocument, $doc];
}

class TJSDocumentDelete extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
			document: 2,
			context: 3,
			deleteDocument: 4
		});
	}

	get document() {
		return this.$$.ctx[2];
	}

	set document(document) {
		this.$$set({ document });
		flush();
	}

	get context() {
		return this.$$.ctx[3];
	}

	set context(context) {
		this.$$set({ context });
		flush();
	}

	get deleteDocument() {
		return this.$$.ctx[4];
	}
}

/* src\component\dialog\document\TJSDocumentImport.svelte generated by Svelte v3.46.0 */

function create_fragment$6(ctx) {
	let form_1;
	let p0;
	let t0;
	let t1;
	let p1;
	let t2;
	let t3;
	let div;
	let label;
	let t5;
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			form_1 = element("form");
			p0 = element("p");
			t0 = text(/*hint1*/ ctx[1]);
			t1 = space();
			p1 = element("p");
			t2 = text(/*hint2*/ ctx[2]);
			t3 = space();
			div = element("div");
			label = element("label");
			label.textContent = `${localize('DOCUMENT.ImportSource')}`;
			t5 = space();
			input = element("input");
			attr(p0, "class", "notes");
			attr(p1, "class", "notes");
			attr(label, "for", "data");
			attr(input, "type", "file");
			attr(input, "id", "data");
			input.required = true;
			attr(div, "class", "form-group");
			attr(form_1, "autocomplete", "off");
		},
		m(target, anchor) {
			insert(target, form_1, anchor);
			append(form_1, p0);
			append(p0, t0);
			append(form_1, t1);
			append(form_1, p1);
			append(p1, t2);
			append(form_1, t3);
			append(form_1, div);
			append(div, label);
			append(div, t5);
			append(div, input);
			/*form_1_binding*/ ctx[8](form_1);

			if (!mounted) {
				dispose = listen(form_1, "submit", prevent_default(/*handleImport*/ ctx[4]));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*hint1*/ 2) set_data(t0, /*hint1*/ ctx[1]);
			if (dirty & /*hint2*/ 4) set_data(t2, /*hint2*/ ctx[2]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(form_1);
			/*form_1_binding*/ ctx[8](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let $doc;
	let { document = void 0 } = $$props;
	const { application } = getContext('external');

	if (!(document instanceof foundry.abstract.Document)) {
		throw new TypeError(`TJSDocumentImport error: 'document' is not an instance of Document.`);
	}

	const doc = new TJSDocument(document,
	{
			delete: application.close.bind(application)
		});

	component_subscribe($$self, doc, value => $$invalidate(7, $doc = value));
	let form;
	let hint1 = localize('DOCUMENT.ImportDataHint1', { document: document.documentName });
	let hint2 = localize('DOCUMENT.ImportDataHint2', { name: document.name });

	async function handleImport() {
		if (!form.data.files.length) {
			return ui.notifications.error('You did not upload a data file!');
		}

		const json = await readTextFromFile(form.data.files[0]);
		const importedDoc = await document.importFromJSON(json);
		application.options.resolve?.(importedDoc);
		application.close();
	}

	function requestSubmit() {
		form.requestSubmit();
	}

	function form_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			form = $$value;
			$$invalidate(0, form);
		});
	}

	$$self.$$set = $$props => {
		if ('document' in $$props) $$invalidate(5, document = $$props.document);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$doc, document*/ 160) {
			if ($doc !== document) {
				if (!(document instanceof foundry.abstract.Document)) {
					throw new TypeError(`TJSDocumentImport error: 'document' is not an instance of Document.`);
				}

				doc.set(document);
				$$invalidate(1, hint1 = localize('DOCUMENT.ImportDataHint1', { document: document.documentName }));
				$$invalidate(2, hint2 = localize('DOCUMENT.ImportDataHint2', { name: document.name }));
				application.data.set('title', `${localize('DOCUMENT.ImportData')}: ${document.name}`);
			}
		}
	};

	return [
		form,
		hint1,
		hint2,
		doc,
		handleImport,
		document,
		requestSubmit,
		$doc,
		form_1_binding
	];
}

class TJSDocumentImport extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { document: 5, requestSubmit: 6 });
	}

	get document() {
		return this.$$.ctx[5];
	}

	set document(document) {
		this.$$set({ document });
		flush();
	}

	get requestSubmit() {
		return this.$$.ctx[6];
	}
}

/* src\component\dialog\document\TJSFolderCreateUpdate.svelte generated by Svelte v3.46.0 */

function create_fragment$5(ctx) {
	let form_1;
	let input0;
	let input0_value_value;
	let t0;
	let input1;
	let input1_value_value;
	let t1;
	let div1;
	let label0;
	let t3;
	let div0;
	let input2;
	let t4;
	let div3;
	let label1;
	let t6;
	let div2;
	let input3;
	let t7;
	let input4;
	let t8;
	let button;
	let t9;
	let div5;
	let label2;
	let t11;
	let div4;

	let raw_value = radioBoxes('sorting', /*sortingModes*/ ctx[7], {
		checked: /*document*/ ctx[0].data.sorting,
		localize: true
	}) + "";

	let mounted;
	let dispose;

	return {
		c() {
			form_1 = element("form");
			input0 = element("input");
			t0 = space();
			input1 = element("input");
			t1 = space();
			div1 = element("div");
			label0 = element("label");
			label0.textContent = `${localize('FOLDER.Name')}`;
			t3 = space();
			div0 = element("div");
			input2 = element("input");
			t4 = space();
			div3 = element("div");
			label1 = element("label");
			label1.textContent = `${localize('FOLDER.Color')}`;
			t6 = space();
			div2 = element("div");
			input3 = element("input");
			t7 = space();
			input4 = element("input");
			t8 = space();
			button = element("button");
			button.innerHTML = `<i class="fas fa-trash-restore"></i>`;
			t9 = space();
			div5 = element("div");
			label2 = element("label");
			label2.textContent = `${localize('FOLDER.SortMode')}`;
			t11 = space();
			div4 = element("div");
			attr(input0, "type", "hidden");
			attr(input0, "name", "type");
			input0.value = input0_value_value = /*document*/ ctx[0].data.type;
			attr(input1, "type", "hidden");
			attr(input1, "name", "parent");
			input1.value = input1_value_value = /*document*/ ctx[0].data.parent;
			attr(input2, "type", "text");
			attr(input2, "name", "name");
			attr(input2, "placeholder", /*newName*/ ctx[6]);
			input2.value = /*name*/ ctx[3];
			input2.required = true;
			attr(div0, "class", "form-fields");
			attr(div1, "class", "form-group");
			attr(input3, "type", "text");
			attr(input3, "name", "color");
			input3.readOnly = true;
			attr(input4, "type", "color");
			attr(input4, "data-edit", "color");
			attr(button, "type", "button");
			attr(div2, "class", "form-fields");
			attr(div3, "class", "form-group");
			attr(div4, "class", "form-fields");
			attr(div5, "class", "form-group");
			attr(form_1, "id", "folder-create");
			attr(form_1, "autocomplete", "off");
		},
		m(target, anchor) {
			insert(target, form_1, anchor);
			append(form_1, input0);
			append(form_1, t0);
			append(form_1, input1);
			append(form_1, t1);
			append(form_1, div1);
			append(div1, label0);
			append(div1, t3);
			append(div1, div0);
			append(div0, input2);
			append(form_1, t4);
			append(form_1, div3);
			append(div3, label1);
			append(div3, t6);
			append(div3, div2);
			append(div2, input3);
			set_input_value(input3, /*colorText*/ ctx[4]);
			append(div2, t7);
			append(div2, input4);
			set_input_value(input4, /*color*/ ctx[1]);
			append(div2, t8);
			append(div2, button);
			append(form_1, t9);
			append(form_1, div5);
			append(div5, label2);
			append(div5, t11);
			append(div5, div4);
			div4.innerHTML = raw_value;
			/*form_1_binding*/ ctx[14](form_1);

			if (!mounted) {
				dispose = [
					listen(input3, "input", /*input3_input_handler*/ ctx[11]),
					listen(input4, "input", /*input4_input_handler*/ ctx[12]),
					listen(button, "click", /*click_handler*/ ctx[13]),
					listen(form_1, "submit", prevent_default(/*saveData*/ ctx[8]))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*document*/ 1 && input0_value_value !== (input0_value_value = /*document*/ ctx[0].data.type)) {
				input0.value = input0_value_value;
			}

			if (dirty & /*document*/ 1 && input1_value_value !== (input1_value_value = /*document*/ ctx[0].data.parent)) {
				input1.value = input1_value_value;
			}

			if (dirty & /*name*/ 8 && input2.value !== /*name*/ ctx[3]) {
				input2.value = /*name*/ ctx[3];
			}

			if (dirty & /*colorText*/ 16 && input3.value !== /*colorText*/ ctx[4]) {
				set_input_value(input3, /*colorText*/ ctx[4]);
			}

			if (dirty & /*color*/ 2) {
				set_input_value(input4, /*color*/ ctx[1]);
			}

			if (dirty & /*document*/ 1 && raw_value !== (raw_value = radioBoxes('sorting', /*sortingModes*/ ctx[7], {
				checked: /*document*/ ctx[0].data.sorting,
				localize: true
			}) + "")) div4.innerHTML = raw_value;		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(form_1);
			/*form_1_binding*/ ctx[14](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

const s_REGEX_HEX_COLOR = /^#(?:[0-9a-fA-F]{3}){1,2}$/;

function instance$5($$self, $$props, $$invalidate) {
	let $doc;
	let { document = void 0 } = $$props;
	const { application } = getContext('external');

	if (!(document instanceof Folder)) {
		throw new TypeError(`TJSFolderCreateUpdate error: 'document' is not an instance of Folder.`);
	}

	const doc = new TJSDocument(document,
	{
			delete: application.close.bind(application)
		});

	component_subscribe($$self, doc, value => $$invalidate(10, $doc = value));
	const newName = localize('DOCUMENT.New', { type: localize(Folder.metadata.label) });

	const sortingModes = {
		a: 'FOLDER.SortAlphabetical',
		m: 'FOLDER.SortManual'
	};

	let form;
	let name = (document?.id) ? document.name : '';
	let color = document?.data?.color;
	let colorText = '';

	function requestSubmit() {
		form.requestSubmit();
	}

	/**
 * Saves any form data / changes to document.
 *
 * @returns {Promise<void>}
 */
	async function saveData(event) {
		const formData = new FormDataExtended(event.target).toObject();

		if (!formData.parent) {
			formData.parent = null;
		}

		let modifiedDoc = document;

		if (document.id) {
			await document.update(formData);
		} else {
			document.data.update(formData);
			modifiedDoc = await Folder.create(document.data);
		}

		application.options.resolve?.(modifiedDoc);
		application.close();
	}

	function input3_input_handler() {
		colorText = this.value;
		((($$invalidate(4, colorText), $$invalidate(1, color)), $$invalidate(10, $doc)), $$invalidate(0, document));
	}

	function input4_input_handler() {
		color = this.value;
		(($$invalidate(1, color), $$invalidate(10, $doc)), $$invalidate(0, document));
	}

	const click_handler = () => $$invalidate(1, color = null);

	function form_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			form = $$value;
			$$invalidate(2, form);
		});
	}

	$$self.$$set = $$props => {
		if ('document' in $$props) $$invalidate(0, document = $$props.document);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$doc, document*/ 1025) {
			if ($doc !== document) {
				if (!(document instanceof Folder)) {
					throw new TypeError(`TJSFolderCreateUpdate error: 'document' is not an instance of Folder.`);
				}

				doc.set(document);
				$$invalidate(3, name = (document?.id) ? document.name : '');
				$$invalidate(1, color = document?.data?.color);

				// Update the dialog button label and title.
				application.data.merge({
					buttons: {
						submit: {
							label: localize((document?.id) ? 'FOLDER.Update' : 'FOLDER.Create')
						}
					},
					title: (document?.id)
					? `${localize('FOLDER.Update')}: ${document.name}`
					: localize('FOLDER.Create')
				});
			}
		}

		if ($$self.$$.dirty & /*color*/ 2) {
			// Reactive block to test color and if it is not a valid hex color then reset colorText and set color to black.
			if (s_REGEX_HEX_COLOR.test(color)) {
				$$invalidate(4, colorText = color);
			} else {
				$$invalidate(4, colorText = null);
				$$invalidate(1, color = '#000000');
			}
		}
	};

	return [
		document,
		color,
		form,
		name,
		colorText,
		doc,
		newName,
		sortingModes,
		saveData,
		requestSubmit,
		$doc,
		input3_input_handler,
		input4_input_handler,
		click_handler,
		form_1_binding
	];
}

class TJSFolderCreateUpdate extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { document: 0, requestSubmit: 9 });
	}

	get document() {
		return this.$$.ctx[0];
	}

	set document(document) {
		this.$$set({ document });
		flush();
	}

	get requestSubmit() {
		return this.$$.ctx[9];
	}
}

/* src\component\dialog\document\TJSFolderDelete.svelte generated by Svelte v3.46.0 */

function create_fragment$4(ctx) {
	let h4;
	let t1;
	let p;

	return {
		c() {
			h4 = element("h4");
			h4.textContent = `${localize('AreYouSure')}`;
			t1 = space();
			p = element("p");
			p.textContent = `${localize('FOLDER.DeleteWarning')}`;
		},
		m(target, anchor) {
			insert(target, h4, anchor);
			insert(target, t1, anchor);
			insert(target, p, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(h4);
			if (detaching) detach(t1);
			if (detaching) detach(p);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let $doc;
	let { document = void 0 } = $$props;
	const { application } = getContext('external');

	if (!(document instanceof Folder)) {
		throw new TypeError(`TJSFolderDelete error: 'document' is not an instance of Folder.`);
	}

	const doc = new TJSDocument(document,
	{
			delete: application.close.bind(application)
		});

	component_subscribe($$self, doc, value => $$invalidate(3, $doc = value));

	async function deleteFolder() {
		// Remove the delete Document function callback as we are intentionally deleting below.
		doc.setOptions({ delete: void 0 });

		const folder = await document.delete({
			deleteSubfolders: true,
			deleteContents: true
		});

		application.options.resolve?.(folder);
		application.close();
	}

	$$self.$$set = $$props => {
		if ('document' in $$props) $$invalidate(1, document = $$props.document);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$doc, document*/ 10) {
			if ($doc !== document) {
				if (!(document instanceof Folder)) {
					throw new TypeError(`TJSFolderDelete error: 'document' is not an instance of Folder.`);
				}

				doc.set(document);
				application.data.set('title', `${localize('FOLDER.Delete')}: ${document.name}`);
			}
		}
	};

	return [doc, document, deleteFolder, $doc];
}

class TJSFolderDelete extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { document: 1, deleteFolder: 2 });
	}

	get document() {
		return this.$$.ctx[1];
	}

	set document(document) {
		this.$$set({ document });
		flush();
	}

	get deleteFolder() {
		return this.$$.ctx[2];
	}
}

/* src\component\dialog\document\TJSFolderExport.svelte generated by Svelte v3.46.0 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i];
	return child_ctx;
}

// (87:12) {#each packs as pack (pack.id)}
function create_each_block$1(key_1, ctx) {
	let option;
	let t_value = /*pack*/ ctx[13].title + "";
	let t;
	let option_value_value;

	return {
		key: key_1,
		first: null,
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*pack*/ ctx[13].metadata.name;
			option.value = option.__value;
			this.first = option;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

function create_fragment$3(ctx) {
	let form;
	let p;
	let t1;
	let div0;
	let label0;
	let t3;
	let select;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t4;
	let div1;
	let label1;
	let t6;
	let input0;
	let t7;
	let div2;
	let label2;
	let t9;
	let input1;
	let mounted;
	let dispose;
	let each_value = /*packs*/ ctx[5];
	const get_key = ctx => /*pack*/ ctx[13].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$1(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
	}

	return {
		c() {
			form = element("form");
			p = element("p");
			p.textContent = `${localize('FOLDER.ExportHint')}`;
			t1 = space();
			div0 = element("div");
			label0 = element("label");
			label0.textContent = `${localize('FOLDER.ExportDestination')}`;
			t3 = space();
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			div1 = element("div");
			label1 = element("label");
			label1.textContent = `${localize('FOLDER.ExportMerge')}`;
			t6 = space();
			input0 = element("input");
			t7 = space();
			div2 = element("div");
			label2 = element("label");
			label2.textContent = `${localize('FOLDER.ExportKeepId')}`;
			t9 = space();
			input1 = element("input");
			attr(p, "class", "notes");
			attr(select, "name", "pack");
			if (/*selected*/ ctx[3] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[9].call(select));
			attr(div0, "class", "form-group");
			attr(input0, "type", "checkbox");
			attr(input0, "name", "merge");
			attr(div1, "class", "form-group");
			attr(input1, "type", "checkbox");
			attr(input1, "name", "keepId");
			attr(div2, "class", "form-group");
			attr(form, "autocomplete", "off");
		},
		m(target, anchor) {
			insert(target, form, anchor);
			append(form, p);
			append(form, t1);
			append(form, div0);
			append(div0, label0);
			append(div0, t3);
			append(div0, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*selected*/ ctx[3]);
			append(form, t4);
			append(form, div1);
			append(div1, label1);
			append(div1, t6);
			append(div1, input0);
			input0.checked = /*merge*/ ctx[0];
			append(form, t7);
			append(form, div2);
			append(div2, label2);
			append(div2, t9);
			append(div2, input1);
			input1.checked = /*keepId*/ ctx[1];

			if (!mounted) {
				dispose = [
					listen(select, "change", /*select_change_handler*/ ctx[9]),
					listen(input0, "change", /*input0_change_handler*/ ctx[10]),
					listen(input1, "change", /*input1_change_handler*/ ctx[11]),
					listen(form, "submit", prevent_default(/*exportData*/ ctx[2]))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*packs*/ 32) {
				each_value = /*packs*/ ctx[5];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, select, destroy_block, create_each_block$1, null, get_each_context$1);
			}

			if (dirty & /*selected, packs*/ 40) {
				select_option(select, /*selected*/ ctx[3]);
			}

			if (dirty & /*merge*/ 1) {
				input0.checked = /*merge*/ ctx[0];
			}

			if (dirty & /*keepId*/ 2) {
				input1.checked = /*keepId*/ ctx[1];
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(form);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let $doc;
	let { document = void 0 } = $$props;
	let { packName } = $$props;
	let { merge } = $$props;
	let { keepId } = $$props;
	let selected;
	const { application } = getContext('external');

	if (!(document instanceof Folder)) {
		throw new TypeError(`TJSFolderExport error: 'document' is not an instance of Folder.`);
	}

	const doc = new TJSDocument(document,
	{
			delete: application.close.bind(application)
		});

	component_subscribe($$self, doc, value => $$invalidate(8, $doc = value));

	// Get eligible pack destinations
	let packs = game.packs.filter(p => p.documentName === document.type && !p.locked);

	if (!packs.length) {
		ui.notifications.warn(localize('FOLDER.ExportWarningNone', { type: document.type }));
		application.options.resolve?.(null);
		application.close();
	}

	selected = packs[0].metadata.name;

	// Configure any default pack by ID search.
	for (const pack of packs) {
		if (pack.title === packName) {
			selected = pack.metadata.name;
		}
	}

	async function exportData() {
		// Find the pack; maybe it has been deleted or locked
		const pack = game.packs.find(p => p?.metadata?.package === 'world' && p?.metadata?.name === selected);

		if (pack instanceof CompendiumCollection && !pack?.locked) {
			await document.exportToCompendium(pack, { updateByName: merge, keepId });
			application.options.resolve?.(pack);
		} else {
			application.options.resolve?.(false);
		}

		application.close();
	}

	function select_change_handler() {
		selected = select_value(this);
		$$invalidate(3, selected);
		$$invalidate(5, packs);
	}

	function input0_change_handler() {
		merge = this.checked;
		$$invalidate(0, merge);
	}

	function input1_change_handler() {
		keepId = this.checked;
		$$invalidate(1, keepId);
	}

	$$self.$$set = $$props => {
		if ('document' in $$props) $$invalidate(7, document = $$props.document);
		if ('packName' in $$props) $$invalidate(6, packName = $$props.packName);
		if ('merge' in $$props) $$invalidate(0, merge = $$props.merge);
		if ('keepId' in $$props) $$invalidate(1, keepId = $$props.keepId);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*packName*/ 64) {
			$$invalidate(6, packName = typeof packName === 'string' ? packName : void 0);
		}

		if ($$self.$$.dirty & /*merge*/ 1) {
			$$invalidate(0, merge = typeof merge === 'boolean' ? merge : true);
		}

		if ($$self.$$.dirty & /*keepId*/ 2) {
			$$invalidate(1, keepId = typeof keepId === 'boolean' ? keepId : true);
		}

		if ($$self.$$.dirty & /*$doc*/ 256) {
			{
				// Update the title if document name changes
				application.data.set('title', `${localize('FOLDER.ExportTitle')}: ${$doc.name}`);
			}
		}
	};

	return [
		merge,
		keepId,
		exportData,
		selected,
		doc,
		packs,
		packName,
		document,
		$doc,
		select_change_handler,
		input0_change_handler,
		input1_change_handler
	];
}

class TJSFolderExport extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			document: 7,
			packName: 6,
			merge: 0,
			keepId: 1,
			exportData: 2
		});
	}

	get document() {
		return this.$$.ctx[7];
	}

	set document(document) {
		this.$$set({ document });
		flush();
	}

	get packName() {
		return this.$$.ctx[6];
	}

	set packName(packName) {
		this.$$set({ packName });
		flush();
	}

	get merge() {
		return this.$$.ctx[0];
	}

	set merge(merge) {
		this.$$set({ merge });
		flush();
	}

	get keepId() {
		return this.$$.ctx[1];
	}

	set keepId(keepId) {
		this.$$set({ keepId });
		flush();
	}

	get exportData() {
		return this.$$.ctx[2];
	}
}

/* src\component\dialog\document\TJSFolderRemove.svelte generated by Svelte v3.46.0 */

function create_fragment$2(ctx) {
	let h4;
	let t1;
	let p;

	return {
		c() {
			h4 = element("h4");
			h4.textContent = `${localize('AreYouSure')}`;
			t1 = space();
			p = element("p");
			p.textContent = `${localize('FOLDER.RemoveWarning')}`;
		},
		m(target, anchor) {
			insert(target, h4, anchor);
			insert(target, t1, anchor);
			insert(target, p, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(h4);
			if (detaching) detach(t1);
			if (detaching) detach(p);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let $doc;
	let { document = void 0 } = $$props;
	const { application } = getContext('external');

	if (!(document instanceof Folder)) {
		throw new TypeError(`TJSFolderRemove error: 'document' is not an instance of Folder.`);
	}

	const doc = new TJSDocument(document,
	{
			delete: application.close.bind(application)
		});

	component_subscribe($$self, doc, value => $$invalidate(3, $doc = value));

	async function removeFolder() {
		// Remove the delete Document function callback as we are intentionally deleting below.
		doc.setOptions({ delete: void 0 });

		const folder = await document.delete({
			deleteSubfolders: false,
			deleteContents: false
		});

		application.options.resolve?.(folder);
		application.close();
	}

	$$self.$$set = $$props => {
		if ('document' in $$props) $$invalidate(1, document = $$props.document);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$doc, document*/ 10) {
			if ($doc !== document) {
				if (!(document instanceof Folder)) {
					throw new TypeError(`TJSFolderRemove error: 'document' is not an instance of Folder.`);
				}

				doc.set(document);
				application.data.set('title', `${localize('FOLDER.Remove')}: ${document.name}`);
			}
		}
	};

	return [doc, document, removeFolder, $doc];
}

class TJSFolderRemove extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { document: 1, removeFolder: 2 });
	}

	get document() {
		return this.$$.ctx[1];
	}

	set document(document) {
		this.$$set({ document });
		flush();
	}

	get removeFolder() {
		return this.$$.ctx[2];
	}
}

/* src\component\dialog\document\TJSFolderRolltable.svelte generated by Svelte v3.46.0 */

function create_fragment$1(ctx) {
	let t_value = localize('FOLDER.CreateTableConfirm') + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let $doc;
	let { document = void 0 } = $$props;
	const { application } = getContext('external');

	if (!(document instanceof Folder)) {
		throw new TypeError(`TJSFolderRolltable error: 'document' is not an instance of Folder.`);
	}

	const doc = new TJSDocument(document,
	{
			delete: application.close.bind(application)
		});

	component_subscribe($$self, doc, value => $$invalidate(3, $doc = value));

	async function createTable() {
		const rollTable = await RollTable.fromFolder(document);
		application.options.resolve?.(rollTable);
		application.close();
	}

	$$self.$$set = $$props => {
		if ('document' in $$props) $$invalidate(1, document = $$props.document);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$doc, document*/ 10) {
			if ($doc !== document) {
				if (!(document instanceof Folder)) {
					throw new TypeError(`TJSFolderRolltable error: 'document' is not an instance of Folder.`);
				}

				doc.set(document);
				application.data.set('title', `${localize('FOLDER.CreateTable')}: ${document.name}`);
			}
		}
	};

	return [doc, document, createTable, $doc];
}

class TJSFolderRolltable extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { document: 1, createTable: 2 });
	}

	get document() {
		return this.$$.ctx[1];
	}

	set document(document) {
		this.$$set({ document });
		flush();
	}

	get createTable() {
		return this.$$.ctx[2];
	}
}

/* src\component\dialog\document\TJSPermissionControl.svelte generated by Svelte v3.46.0 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	return child_ctx;
}

// (161:3) {#each users as data (data.user.id)}
function create_each_block(key_1, ctx) {
	let div;
	let label;
	let t0_value = /*data*/ ctx[15].user.name + "";
	let t0;
	let t1;
	let select;
	let raw_value = selectOptions(/*playerLevels*/ ctx[4], { selected: /*data*/ ctx[15].level }) + "";
	let select_name_value;
	let t2;

	return {
		key: key_1,
		first: null,
		c() {
			div = element("div");
			label = element("label");
			t0 = text(t0_value);
			t1 = space();
			select = element("select");
			t2 = space();
			attr(select, "name", select_name_value = /*data*/ ctx[15].user.id);
			attr(select, "data-dtype", "Number");
			attr(div, "class", "form-group");
			toggle_class(div, "hidden", /*data*/ ctx[15].user.isGM);
			this.first = div;
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, label);
			append(label, t0);
			append(div, t1);
			append(div, select);
			select.innerHTML = raw_value;
			append(div, t2);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*users*/ 32 && t0_value !== (t0_value = /*data*/ ctx[15].user.name + "")) set_data(t0, t0_value);
			if (dirty & /*playerLevels, users*/ 48 && raw_value !== (raw_value = selectOptions(/*playerLevels*/ ctx[4], { selected: /*data*/ ctx[15].level }) + "")) select.innerHTML = raw_value;
			if (dirty & /*users*/ 32 && select_name_value !== (select_name_value = /*data*/ ctx[15].user.id)) {
				attr(select, "name", select_name_value);
			}

			if (dirty & /*users*/ 32) {
				toggle_class(div, "hidden", /*data*/ ctx[15].user.isGM);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment(ctx) {
	let form_1;
	let p;
	let t0;
	let t1;
	let div;
	let label;
	let t3;
	let select;
	let raw_value = selectOptions(/*defaultLevels*/ ctx[3], { selected: /*currentDefault*/ ctx[2] }) + "";
	let t4;
	let hr;
	let t5;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let mounted;
	let dispose;
	let each_value = /*users*/ ctx[5];
	const get_key = ctx => /*data*/ ctx[15].user.id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			form_1 = element("form");
			p = element("p");
			t0 = text(/*instructions*/ ctx[1]);
			t1 = space();
			div = element("div");
			label = element("label");
			label.textContent = `${localize('PERMISSION.AllPlayers')}`;
			t3 = space();
			select = element("select");
			t4 = space();
			hr = element("hr");
			t5 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(p, "class", "notes");
			attr(select, "name", "default");
			attr(select, "data-dtype", "Number");
			attr(div, "class", "form-group");
			attr(form_1, "id", "permission-control");
		},
		m(target, anchor) {
			insert(target, form_1, anchor);
			append(form_1, p);
			append(p, t0);
			append(form_1, t1);
			append(form_1, div);
			append(div, label);
			append(div, t3);
			append(div, select);
			select.innerHTML = raw_value;
			append(form_1, t4);
			append(form_1, hr);
			append(form_1, t5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(form_1, null);
			}

			/*form_1_binding*/ ctx[12](form_1);

			if (!mounted) {
				dispose = listen(form_1, "submit", prevent_default(/*saveData*/ ctx[7]));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*instructions*/ 2) set_data(t0, /*instructions*/ ctx[1]);
			if (dirty & /*defaultLevels, currentDefault*/ 12 && raw_value !== (raw_value = selectOptions(/*defaultLevels*/ ctx[3], { selected: /*currentDefault*/ ctx[2] }) + "")) select.innerHTML = raw_value;
			if (dirty & /*users, selectOptions, playerLevels*/ 48) {
				each_value = /*users*/ ctx[5];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, form_1, destroy_block, create_each_block, null, get_each_context);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(form_1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*form_1_binding*/ ctx[12](null);
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $doc;
	let { document = void 0 } = $$props;
	const { application } = getContext('external');

	if (!(document instanceof foundry.abstract.Document)) {
		throw new TypeError(`TJSPermissionControl error: 'document' is not an instance of Document.`);
	}

	const doc = new TJSDocument(document,
	{
			delete: application.close.bind(application)
		});

	component_subscribe($$self, doc, value => $$invalidate(11, $doc = value));
	let form, instructions;
	let currentDefault, defaultLevels, playerLevels, users;
	let isFolder = document instanceof Folder;

	/**
 * Builds the data for the permission dialog from the document.
 */
	function getData() {
		// User permission levels
		const playerLevels = {};

		if (isFolder) {
			playerLevels['-2'] = localize('PERMISSION.DEFAULT');
			playerLevels['-1'] = localize('PERMISSION.NOCHANGE');
		} else {
			playerLevels['-1'] = localize('PERMISSION.DEFAULT');
		}

		for (const [n, l] of Object.entries(CONST.DOCUMENT_PERMISSION_LEVELS)) {
			playerLevels[l] = localize(`PERMISSION.${n}`);
		}

		// Default permission levels
		const defaultLevels = foundry.utils.deepClone(playerLevels);

		if (isFolder) {
			delete defaultLevels['-2'];
		} else {
			delete defaultLevels['-1'];
		}

		// Player users
		const users = game.users.map(u => {
			return {
				user: u,
				level: $doc.data.permission?.[u.id] ?? '-1'
			};
		});

		// Construct and return the data object
		return {
			currentDefault: $doc.data.permission?.default ?? '-1',
			defaultLevels,
			playerLevels,
			users
		};
	}

	function requestSubmit() {
		form.requestSubmit();
	}

	/**
 * Saves any form data / changes to document.
 *
 * @returns {Promise<void>}
 */
	async function saveData(event) {
		if (!($doc instanceof foundry.abstract.Document)) {
			return;
		}

		const formData = new FormDataExtended(event.target).toObject();

		// Collect user permissions
		const perms = {};

		for (const [user, level] of Object.entries(formData)) {
			if (level === -1) {
				delete perms[user];
				continue;
			}

			perms[user] = level;
		}

		// Update all documents in a Folder
		if ($doc instanceof Folder) {
			const cls = getDocumentClass($doc.type);

			const updates = $doc.content.map(e => {
				const p = foundry.utils.deepClone(e.data.permission);

				for (const [k, v] of Object.entries(perms)) {
					if (v === -2) {
						delete p[k];
					} else {
						p[k] = v;
					}
				}

				return { _id: e.id, permission: p };
			});

			await cls.updateDocuments(updates, {
				diff: false,
				recursive: false,
				noHook: true
			});

			application.options.resolve?.($doc);
			application.close();
		}

		// Update a single Document
		await $doc.update({ permission: perms }, {
			diff: false,
			recursive: false,
			noHook: true
		});

		application.options.resolve?.($doc);
		application.close();
	}

	function form_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			form = $$value;
			$$invalidate(0, form);
		});
	}

	$$self.$$set = $$props => {
		if ('document' in $$props) $$invalidate(8, document = $$props.document);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$doc, document*/ 2304) {
			if ($doc !== document) {
				if (!(document instanceof foundry.abstract.Document)) {
					throw new TypeError(`TJSPermissionControl error: 'document' is not an instance of Document.`);
				}

				doc.set(document);
				const title = localize('PERMISSION.Title');
				application.data.set('title', `${title}: ${document.name}`);
			}
		}

		if ($$self.$$.dirty & /*$doc, isFolder*/ 3072) {
			{
				$$invalidate(2, { currentDefault, defaultLevels, playerLevels, users } = getData(), currentDefault, (($$invalidate(3, defaultLevels), $$invalidate(11, $doc)), $$invalidate(10, isFolder)), (($$invalidate(4, playerLevels), $$invalidate(11, $doc)), $$invalidate(10, isFolder)), (($$invalidate(5, users), $$invalidate(11, $doc)), $$invalidate(10, isFolder)));
				$$invalidate(10, isFolder = $doc instanceof Folder);

				$$invalidate(1, instructions = localize(isFolder
				? 'PERMISSION.HintFolder'
				: 'PERMISSION.HintDocument'));
			}
		}
	};

	return [
		form,
		instructions,
		currentDefault,
		defaultLevels,
		playerLevels,
		users,
		doc,
		saveData,
		document,
		requestSubmit,
		isFolder,
		$doc,
		form_1_binding
	];
}

class TJSPermissionControl extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { document: 8, requestSubmit: 9 });
	}

	get document() {
		return this.$$.ctx[8];
	}

	set document(document) {
		this.$$set({ document });
		flush();
	}

	get requestSubmit() {
		return this.$$.ctx[9];
	}
}

export { TJSDocumentCreate, TJSDocumentDelete, TJSDocumentImport, TJSFolderCreateUpdate, TJSFolderDelete, TJSFolderExport, TJSFolderRemove, TJSFolderRolltable, TJSPermissionControl };
//# sourceMappingURL=index.js.map
